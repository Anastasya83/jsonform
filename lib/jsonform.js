/**
 * @fileoverview Core of the JSON Form client-side library.
 *
 * Generates an HTML form from a structured data model and a layout description.
 *
 * The library may also validate inputs entered by the user against the data model
 * upon form submission and create the structured data object initialized with the
 * values that were submitted.
 *
 * The library depends on:
 *  - jQuery
 *  - the underscore library
 *  - a JSON parser/serializer. Nothing to worry about in modern browsers.
 *  - the JSONFormValidation library (in jsv.js) for validation purpose
 *
 * See documentation at:
 * http://developer.joshfire.com/doc/dev/ref/jsonform
 */

(function($, _, JSON, global) {

  /**
   * Regular expression used to extract array indexes in input field names
   */
  var reArray = /\[([0-9]+)\]$/;

  /**
   * The jsonform object whose methods will be exposed to the window object
   */
  var jsonform = {};

  // from Underscorejs
  // We copy it here to avoid conflicts with _.templateSettings
  var _template = function(str, data) {

    var c  = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g
    };

    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +
      'with(obj||{}){__p.push(\'' +
      str.replace(/\\/g, '\\\\')
         .replace(/'/g, "\\'")
         .replace(c.interpolate, function(match, code) {
           return "'," + code.replace(/\\'/g, "'") + ",'";
         })
         .replace(c.evaluate || null, function(match, code) {
           return "');" + code.replace(/\\'/g, "'")
                              .replace(/[\r\n\t]/g, ' ') + "__p.push('";
         })
         .replace(/\r/g, '\\r')
         .replace(/\n/g, '\\n')
         .replace(/\t/g, '\\t') +
         "');}return __p.join('');";

    var func = new Function('obj', tmpl);

    return data ? func(data) : func;
  };


// From backbonejs
// TODO replace by (new Option(JSON.stringify(html))).innerHTML ?
var escapeHTML = function(string) {
  if (!string) return '';
  return ('' + string).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
};

/**
 * Escapes selector name for use with jQuery
 *
 * All meta-characters listed in jQuery doc are escaped:
 * http://api.jquery.com/category/selectors/
 *
 * @function
 * @param {String} selector The jQuery selector to escape
 * @return {String} The escaped selector.
 */
var escapeSelector = function (selector) {
  return selector.replace(/([\!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, '\\$1');
};

/**
 * Initializes tabular sections in forms. Such sections are generated by the
 * 'selectfieldset' type of elements in JSON Form.
 *
 * Input fields that are not visible are automatically disabled
 * not to appear in the submitted form. That's on purpose, as tabs
 * are meant to convey an alternative (and not a sequence of steps).
 *
 * The tabs menu is not rendered as tabs but rather as a select field because
 * it's easier to grasp that it's an alternative.
 *
 * Code based on bootstrap-tabs.js, updated to:
 * - react to option selection instead of tab click
 * - disable input fields in non visible tabs
 * - disable the possibility to have dropdown menus (no meaning here)
 * - act as a regular function instead of as a jQuery plug-in.
 *
 * @function
 * @param {Object} tabs jQuery object that contains the tabular sections
 *  to initialize. The object may reference more than one element.
 */
var initializeTabs = function (tabs) {
  var activate = function (element, container) {
    container
      .find('> .active')
      .removeClass('active');
    element.addClass('active');
  };

  var tabClicked = function (e) {
    var $option = $("option:selected", $(this)),
      $select = $(this),
      href = $option.attr('value'),
      $href;

    if ( /^#\w+/.test(href) ) {
      href = href.substring(href.indexOf('#') + 1);
      e.preventDefault();
      if ($option.hasClass('active')) {
        return;
      }

      $href = $("#" + escapeSelector(href));
      activate($option, $select);
      activate($href, $href.parent());

      // Enable all fields in the targeted tab
      $href.find('input, textarea, select').removeAttr('disabled');

      // Disable all fields in other tabs
      $href.parent()
        .children(':not(#' + escapeSelector(href) + ')')
        .find('input, textarea, select')
        .attr('disabled', 'disabled');
    }
  };

  tabs.each(function () {
    $(this).delegate('select.nav', 'change', tabClicked);
    $('select.nav').each(function () {
      $(this).val($('.active', $(this)).attr('value'));
    });
  });
};


// Twitter bootstrap-friendly HTML boilerplate for standard inputs
jsonform.fieldTemplate = function(inner) {
  return '<div class="control-group jsonform-error-<%= elt.keydash %> <%= elt.htmlClass?elt.htmlClass:"" %>">'+
          '<label class="control-label" for="<%= elt.id %>"><% if (!elt.notitle) { %><%= elt.title || schema.title %><% } %></label>'+
            '<div class="controls <% if (elt.prepend) { %>input-prepend<% } %> <% if (elt.append) { %>input-append<% } %>">'+
            '<% if (elt.prepend) { %><span class="add-on"><%= elt.prepend %></span><% } %>'+
            inner+
            '<% if (elt.append) { %><span class="add-on"><%= elt.append %></span><% } %>'+
            '<% if (schema.description) { %><span class="help-inline"><%= schema.description %></span><% } %>'+
            '<span class="help-block jsonform-errortext" style="display:none;"></span>'+
          '</div></div>';
};

var fileDisplayTemplate = '<% if (elt.value.type=="image") { %><img id="jsonformpreview-<%= elt.id %>" src="<%= elt.value.url %>" /><% } else { %><a href="<%= elt.value.url %>"><%= elt.value.name %></a> (<%= Math.ceil(elt.value.size/1024) %>kB)<% } %><br/>';

jsonform.elementTypes = {
  'text':{
    'template':'<input class="input-xlarge xlarge" type="text" name="<%= elt.name %>" value="<%= escape(elt.value) %>" id="<%= elt.id %>" />',
    'fieldtemplate':true
  },
  'password':{
    'template':'<input class="input-xlarge xlarge" type="password" name="<%= elt.name %>" value="<%= escape(elt.value) %>" id="<%= elt.id %>" />',
    'fieldtemplate':true
  },
  'textarea':{
    'template':'<textarea id="<%= elt.id %>" name="<%= elt.name %>" style="height:<%= elt.height || "200px" %>;width:<%= elt.width || "100%" %>;"><%= elt.value %></textarea>',
    'fieldtemplate':true
  },
  'wysihtml5':{
    'template':'<textarea id="<%= elt.id %>" name="<%= elt.name %>" style="height:<%= elt.height || "300px" %>;width:<%= elt.width || "100%" %>;"><%= elt.value %></textarea>',
    'fieldtemplate':true,
    'handlers':{
      "insert":function(evt, elt) {
        
         var setup = function() {

            //protect from double init
            if ($('#'+elt.id).data("wysihtml5")) return;
            $('#'+elt.id).data("wysihtml5_loaded",true);
            
            $('#'+elt.id).wysihtml5({
              "html": true,
              "link": false, //TODO replug when adding new twitter bootstrap javascripts
              "font-styles":false,
              "image": false 
              //"events":{}
            });
         };

        //Is there a setup hook?
        if (window.jsonform_wysihtml5_setup) {
          window.jsonform_wysihtml5_setup(setup);
          return;
        }

        //Wait until wysihtml5 is loaded
        var itv = setInterval(function() {
          if (window.wysihtml5) {
            clearInterval(itv);
            setup(); 
          }
        },1000);

      }
    }
  },
  'ace':{
    'template':'<div id="<%= elt.id %>" style="position:relative;height:<%= elt.height || "300px" %>;"><div id="<%= elt.id %>__ace" style="width:<%= elt.width || "100%" %>;height:<%= elt.height || "300px" %>;"><%= elt.value %></div><input type="hidden" name="<%= elt.name %>" id="<%= elt.id %>__hidden" value="<%= escape(elt.value) %>"/></div>',
    'fieldtemplate':true,
    'handlers':{
      "insert":function(evt, elt) {
        var setup = function() {
          var ace = window.ace;
          var editor = ace.edit(elt.id+"__ace");
          editor.setTheme("ace/theme/"+(elt.aceTheme||"twilight"));

          if (elt.aceMode) {
            var mode = ace.require("ace/mode/"+elt.aceMode).Mode;
            editor.getSession().setMode(new mode());
          }
          editor.getSession().setTabSize(2);

          // Set the contents of the initial manifest file
          editor.getSession().setValue(elt.value||"");

          //TODO this is clearly sub-optimal
          editor.getSession().on('change', function() {
            $("#"+elt.id+"__hidden").val(editor.getSession().getValue());
          });

          editor.on('blur', function() {
            $("#"+elt.id+"__hidden").change();
            $("#"+elt.id+"__hidden").trigger("blur");
          });
          editor.on('focus', function() {
            $("#"+elt.id+"__hidden").trigger("focus");
          });
        }

        //Is there a setup hook?
        if (window.jsonform_ace_setup) {
          window.jsonform_ace_setup(setup);
          return;
        }

        //Wait until ACE is loaded
        var itv = setInterval(function() {
          if (window.ace) {
            clearInterval(itv);
            setup(); 
          }
        },1000);
        
      }
    }
  },
  'checkbox':{
    // NB: if inlinetitle is not set, a good old (sigh!) non breakable space is
    // inserted to avoid float clearing problems
    'template':'<label class="checkbox"><input type="checkbox" id="<%= elt.id %>" name="<%= elt.name %>" value="1" <% if (elt.value) {%>checked<% } %> /><span><%= elt.inlinetitle || " " %></span></label>',
    'fieldtemplate':true
  },
  'file':{
    'template':'<input class="input-file" id="<%= elt.id %>" name="<%= elt.name %>" type="file" />',
    'fieldtemplate':true
  },
  'file-transloadit':{
    'template':'<% if (elt.value && (elt.value.type||elt.value.url)) { %>'+fileDisplayTemplate+'<% } %><input id="<%= elt.id %>" type="file" name="_transloadit_<%= elt.name %>" /><input type="hidden" id="<%= elt.id %>" name="<%= elt.name %>" value=\'<%= escape(JSON.stringify(elt.value)) %>\' />',
    'fieldtemplate':true
  },
  'select':{
    'template':'<select name="<%= elt.name %>" id="<%= elt.id %>"> <% _.each(elt.options, function(key, val) { if(key instanceof Object) { if (elt.value == key.value) { %> <option selected value="<%= key.value %>"><%= key.title %></option> <% } else { %> <option value="<%= key.value %>"><%= key.title %></option> <% }} else { if (elt.value == key) { %> <option selected value="<%= key %>"><%= key %></option> <% } else { %><option value="<%= key %>"><%= key %></option> <% }}}); %> </select>',
    'fieldtemplate':true
  },
  'radios':{
    'template':'<% _.each(elt.options, function(key, val) { %><label class="radio"><input type="radio" <% if (elt.value == key) { %> checked="checked" <% } %> name="<%= elt.name %>" value="<%= key %>"><span><%= key %></span></label><% }); %>',
    'fieldtemplate':true
  },
  'checkboxesitem':{
    // NB: if title is not set, a good old (sigh!) non breakable space is
    // inserted to avoid float clearing problems
    'template':'<label class="checkbox <%= elt.htmlClass?elt.htmlClass:"" %>"><input type="checkbox" <% if (elt.value) { %> checked="checked" <% } %> name="<%= elt.name %>" value="1"><span><%= elt.title || schema.title || " " %></span></label>'
  },
  'checkboxes':{
    'template':'<%= elt.itemshtml %>',
    'fieldtemplate':true
  },
  'array':{
    'template':'<ul id="<%= elt.id %>" class="_jsonform-array-ul" style="list-style-type:none;"><%= elt.itemshtml %></ul><span class="_jsonform-array-buttons"><a href="#" class="_jsonform-array-addmore">Add more</a> | <a href="#"  class="_jsonform-array-deletelast">Delete last</a></span>',
    'fieldtemplate':true
  },
  'help':{
    'template':'<span class="help-block" style="padding-top:5px"><%= elt.helpvalue %></span>',
    'fieldtemplate':true
  },
  'fieldset':{
    'template': '<fieldset class="control-group jsonform-error-<%= elt.keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:"" %>" ' +
      '<% if (elt.id) { %> id="<%= elt.id %>"<% } %>' +
      '>' +
      '<% if (elt.legend) { %><legend><%= elt.legend %></legend><% } %>' +
      '<% if (elt.expandable) { %><div class="control-group"><% } %>' +
      '<%= elt.itemshtml %>' +
      '<% if (elt.expandable) { %></div><% } %>' +
      '</fieldset>'
  },
  'advancedfieldset': {
    'template': '<fieldset' +
      '<% if (elt.id) { %> id="<%= elt.id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Advanced options</legend>' +
      '<div class="control-group">' +
      '<%= elt.itemshtml %>' +
      '</div>' +
      '</fieldset>'
  },
  'authfieldset': {
    'template': '<fieldset' +
      '<% if (elt.id) { %> id="<%= elt.id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Authentication settings</legend>' +
      '<div class="control-group">' +
      '<%= elt.itemshtml %>' +
      '</div>' +
      '</fieldset>'
  },
  'submit':{
    'template':'<input type="submit" <% if (elt.id) { %> id="<%= elt.id %>" <% } %> class="btn btn-primary <%= elt.htmlClass?elt.htmlClass:"" %>" value="<%= elt.value %>"/>'
  },
  'button':{
    'template':'<button id="<%= elt.id %>" class="btn <%= elt.htmlClass?elt.htmlClass:"" %>"><%= elt.title %></button>'
  },
  'actions':{
    'template':'<div class="form-actions <%= elt.htmlClass?elt.htmlClass:"" %>"><%= elt.itemshtml %></div>'
  },
  'hidden':{
    'template':'<input type="hidden" id="<%= elt.id %>" name="<%= elt.name %>" value="<%= escape(elt.value) %>" />'
  },
  'selectfieldset': {
    'template': '<fieldset class="tab-container <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<% if (elt.legend) { %><legend><%= elt.legend %></legend><% } %>' +
      '<div class="tabbable">' +
        '<div class="control-group">' +
          '<label class="control-label" for="<%= elt.id %>"><% if (!elt.notitle) { %><%= elt.title %><% } %></label>' +
          '<div class="controls">' +
            '<select class="nav">' +
            '<% _.each(elt.items, function(item, idx) { %>' +
              '<option value="#<%= item.id %>"' +
              '<% if (item.active) { %> class="active"<% } %>' +
              '>' +
              '<%= item.legend %></option>' +
              '<% }); %>' +
            '</select>' +
          '</div>' +
        '</div>' +
        '<div class="tab-content">' +
          '<%= elt.itemshtml %>' +
        '</div>' +
      '</div>' +
      '</fieldset>'
  },
  'optionfieldset': {
    'template': '<div class="<%= elt.htmlClass?elt.htmlClass:"" %> tab-pane' +
      '<% if (elt.active) { %> active"<% } %>"' +
      '<% if (elt.id) { %> id="<%= elt.id %>"<% } %>' +
      '>' +
      '<%= elt.itemshtml %>' +
      '</div>'
  },
  'object': {
    'template': '<%= elt.itemshtml %>'
  }
};

/*
Legacy elements:

'file-jquery-multiple': jsonform.defaultFieldTemplate('<div id="<%= elt.id %>"><div class="fileupload-buttonbar"><label class="fileinput-button"><span>Add files...</span><input type="file" name="<%= elt.name %>" multiple></label><button type="submit" class="start">Start upload</button><button type="reset" class="cancel">Cancel upload</button><button type="button" class="delete">Delete files</button></div><div class="fileupload-content"><table class="files"></table><div class="fileupload-progressbar"></div></div></div>'),
*/

//Allow to access subproperties by splitting "."
/**
 * Retrieves the key identified by a path selector in the structured object.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * @function
 * @param {Object} obj Structured object to parse
 * @param {String} key Path to the key to retrieve
 * @param {boolean} ignoreArrays True to use first element in an array when
 *   stucked on a property. This parameter is basically only useful when
 *   parsing a JSON schema for which the "items" property may either be an
 *   object or an array with one object (only one because JSON form does not
 *   support mix of items for arrays).
 * @return {Object} The key's value.
 */
var getObjKey = function (obj, key, ignoreArrays) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;

  for (var i = 0; i < keyparts.length; i++) {
    if (typeof innerobj !== "object") return null;
    subkey = keyparts[i];
    arrayMatch = subkey.match(reArray);
    if (arrayMatch) {
      // Subkey is part of an array
      subkey = subkey.replace(reArray, '');
      if (!_.isArray(innerobj[subkey])) {
        return null;
      }
      innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
    }
    else if (ignoreArrays && !innerobj[subkey] && _.isArray(innerobj) && innerobj[0]) {
      innerobj = innerobj[0][subkey];
    }
    else {
      innerobj = innerobj[subkey];
    }
  }

  if (ignoreArrays && _.isArray(innerobj) && innerobj[0]) {
    return innerobj[0];
  }
  else {
    return innerobj;
  }
};


/**
 * Sets the key identified by a path selector to the given value.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * The hierarchy is automatically created if it does not exist yet.
 *
 * @function
 * @param {Object} obj The object to build
 * @param {String} key The path to the key to set where each level
 *  is separated by a dot, and array items are flagged with [x].
 * @param {Object} value The value to set, may be of any type.
 */
var setObjKey = function(obj,key,value) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;
  for (var i = 0; i < keyparts.length-1; i++) {
    subkey = keyparts[i];
    arrayMatch = subkey.match(reArray);
    if (arrayMatch) {
      // Subkey is part of an array
      subkey = subkey.replace(reArray, '');
      if (!_.isArray(innerobj[subkey])) {
        innerobj[subkey] = [];
      }
      if (typeof innerobj[subkey][parseInt(arrayMatch[1], 10)] !== 'object') {
        innerobj[subkey][parseInt(arrayMatch[1], 10)] = {};
      }
      innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
    }
    else {
      // "Normal" subkey
      if (typeof innerobj[subkey] !== 'object') {
        innerobj[subkey] = {};
      }
      innerobj = innerobj[subkey];
    }
  }

  // Set the final value
  subkey = keyparts[keyparts.length - 1];
  arrayMatch = subkey.match(reArray);
  if (arrayMatch) {
    subkey = subkey.replace(reArray, '');
    if (!_.isArray(innerobj[subkey])) {
      innerobj[subkey] = [];
    }
    innerobj[subkey][parseInt(arrayMatch[1], 10)] = value;
  }
  else {
    innerobj[subkey] = value;
  }
};


/**
 * Retrieves the key definition from the given schema.
 *
 * The key is identified by the path that leads to the key in the
 * structured object that the schema would generate. Each level is
 * separated by a '.'. Array levels are marked with []. For instance:
 *  foo.bar[].baz
 * ... to retrieve the definition of the key at the following location
 * in the JSON schema (using a dotted path notation):
 *  foo.properties.bar.items.properties.baz
 *
 * @function
 * @param {Object} schema The JSON schema to retrieve the key from
 * @param {String} key The path to the key, each level being separated
 *  by a dot and array items being flagged with [].
 * @return {Object} The key definition in the schema, null if not found.
 */
var getSchemaKey = function(schema,key) {
  var schemaKey = key
    .replace(/\./g, '.properties.')
    .replace(/\[.*\](\.|$)/g, '.items$1');
  return getObjKey(schema, schemaKey, true);
};


/**
 * Returns true if the element contains some pre-defined value.
 *
 * @function
 * @param {Object} element Form element
 * @returns {boolean} true when there exist some value for the
 *  given form element, false otherwise
 */
var formElementHasValue = function (element, options) {
  var i = 0;
  var valueFound = false;

  if (_.isString(element)) {
    valueFound = element.value ||
      (options.value && getObjKey(options.value, element));
  }
  else if (element.key) {
    valueFound = element.value ||
      (options.value && getObjKey(options.value, element.key));
  }

  if (!valueFound && element.items) {
    for (i = 0; i < element.items.length; i++) {
      valueFound = formElementHasValue(element.items[i], options);
      if (valueFound) {
        break;
      }
    }
  }
  return valueFound;
};


/**
 * Form fragment class.
 *
 * Holds the representation of a fragment of a form.
 *
 * @class
 */
var formFragment = function() {
  this.html = "";
  this.eventhandlers = [];
};


/**
 * Concatenates the given form fragment with the underlying fragment.
 *
 * Event handlers are preserved.
 *
 * @function
 * @param {formFragment} form2 Form fragment to concatenate
 */
formFragment.prototype.concat = function(form2) {
  this.html += form2.html;
  this.eventhandlers = this.eventhandlers.concat(form2.eventhandlers);
};


/**
 * Builds the HTML fragment of a JSON form element.
 *
 * The function is recursive, calling "build" on the element's children
 * whenever appropriate.
 *
 * Main function of the form generation that deals with the different
 * types of sections to generate.
 *
 * TODO: the support for complex arrays is clumsy at best for the time
 * being. Only one level of arrays is supported. To allow for proper
 * nesting of arrays, the complete path to the underlying data section
 * or element should be given as a parameter. Right now, we only have
 * the path without array indexes, and a placeholder that gets replaced
 * by the index, e.g.: foo[XXXkeyXXX].bar. That said, one level of arrays
 * is enough for most cases.
 *
 * @function
 * @param {Object} elt The JSON form element to build
 * @param {Object} options The JSON form options definition (schema in particular)
 */
formFragment.prototype.buildOneElement = function (elt,options) {
  var schema = {};
  var self = this;

  //we re-set a lot of properties (name, id, value) =>
  //make a copy of the element so that we don't pollute the original object too much
  //todo, won't for for embedded objects (but we can't use JSON to do a deep copy because
  //of the event handlers!)
  elt = _.clone(elt);
  if (elt.items) elt.items = _.map(elt.items,_.clone);

  if (elt.key) {
    // The element to render is directly linked to a key in the JSON schema,
    elt.name = elt.name || elt.key;
    elt.id = elt.id || "jsonform-elt-"+elt.key;

    schema = getSchemaKey(options.schema.properties, elt.key);
    if (!schema) {
      throw new Error(elt.key + ' has no schema');
    }

    //Plug custom behaviours
    if (options.onElementSchema) {
      options.onElementSchema(elt,schema);
    }

    if (options.value) {
      // Form has already been submitted,
      // use former value if defined.
      // Don't set the field to its default value otherwise
      // (since user has already rejected it)
      if (getObjKey(options.value,elt.key)) {
        elt.value = getObjKey(options.value,elt.key);
      }
    }
    else {
      // No previously submitted form result,
      // use schema default value if defined
      if (schema['default']) {
        elt.value = schema['default'];
      }
    }

    //Plug custom behaviours
    if (options.onElementValue) {
      options.onElementValue(elt,schema);
    }

    elt.keydash = elt.key.replace(/\./g,"---");
  }
  else if (elt.type && (elt.type === 'selectfieldset') && elt.items) {
    // Tabs need IDs on children.
    // Active tab is the first one, except if form values are available,
    // in which case it's the first tab for which there is some value
    // available (or back to the first one if there are none)
    var activeItem = _.find(elt.items, function (item) {
      return formElementHasValue(item, options);
    });
    if (!activeItem) {
      activeItem = elt.items[0];
    }
    _.each(elt.items, function (item) {
      item.id = item.id || ("jsonform-elt-counter-" + _.uniqueId());
      if (item === activeItem) {
        item.active = true;
      }
    });
  }

  elt.iddot = escapeSelector(elt.id||"");

  // should empty strings be included in the final value?
  // todo: it's rather unclean to pass it through the schema.
  if (elt.allowEmpty) {
    schema._jsonform_allowEmpty = true;
  }

  // Set the form element type from the schema if not already done
  if (!elt.type) {
    if ((schema.type == 'number' || schema.type == 'string') && !schema['enum']) {
      elt.type = 'text';
    } else if (schema.type=='boolean') {
      elt.type = 'checkbox';
    } else if (!_.isUndefined(schema['enum'])) {
      elt.type = 'select';
    } else if (schema.type=='array') {
      elt.type = 'array';
    } else if (schema.type=='object') {
      elt.type = 'object';
    }
  }

  // Use enumeration list defined in the schema
  // unless overridden in the definition of the form element
  // or unless there's a titleMap defined
  if (!_.isUndefined(schema['enum']) && !elt.options) {
    if (elt.titleMap) {
      elt.options = _.map(schema['enum'], function (value) {
        return {
          value: value,
          title: elt.titleMap[value] || value
        };
      });
    }
    else {
      elt.options = schema['enum'];
    }
  }

  // Compute subforms for elements that have children
  // (arrays, objects, list of checkboxes, fieldsets)
  if (elt.type === 'array') {
    // An array has an unknown number of items. The form generated
    // includes "add more/remove last" buttons to let the user choose
    // the number of items in the array before he submits the form.
    // Array items may be complex forms themselves, allowing for nesting.

    var genSubElementFormWithValue = function(v,elt,idx) {
      var suboptions = _.clone(options);
      var valueFound = false;

      if (elt.key) {
        // Array is linked to a schema key,
        // follow the schema definition to render the subform
        _.extend(suboptions, {
          "schema": {"XXXkeyXXX": _.isArray(schema.items) ? schema.items[0] : schema.items},
          "value": {"XXXkeyXXX": v},
          "form": [
            {
              "key": "XXXkeyXXX",
              "parentKey": elt.key //To be able to do custom handlers on child elements
            }
          ]
        });

        // Hard to tell whether a value was found actually
        valueFound = v;
      }
      else {
        // Array's layout is defined, use it to render the subform
        // TODO: default values not taken into account here, but these values
        // are going to be complex objects (as opposed to a simple string or
        // number), so not that easy to integrate.
        
        elt.id = "jsonform-elt-counter-" + _.uniqueId();
        elt.iddot = escapeSelector(elt.id||"");


        var flagArrayItems = function (element) {
          var currItem = null;
          var found = false;

          if (!element.items) {
            return found;
          }

          for (var k = 0; k < element.items.length; k++) {
            currItem = element.items[k];
            if (_.isString(currItem)) {
              element.items[k] = currItem.replace(/\[[0-9]*\]/, '[' + idx + ']');
              found = found ||
                currItem.value ||
                (v && getObjKey(v, element.items[k]));
            }
            else if (currItem.key) {
              element.items[k].key = currItem.key.replace(/\[[0-9]*\]/, '[' + idx + ']');
              found = found ||
                currItem.value ||
                (v && getObjKey(v, element.items[k].key));
            }
            
            found = flagArrayItems(currItem) || found;
          }

          return found;
        };

        valueFound = flagArrayItems(elt);

        _.extend(suboptions, {
          "schema": options.schema,
          "form": [
            {
              "type": "object",
              "items": elt.items
            }
          ],
          "value": v
        });
      }

      var subForm = new formFragment();
      subForm.build(suboptions);
      if ((idx !== 'XXXkeyXXX') && (valueFound || (idx === 0))) {
        if (elt.key) {
          elt.itemshtml += "<li>" +
            subForm.html.replace(/XXXkeyXXX/g, elt.key + "[" + idx + "]").replace(/XXXidxXXX/g, (idx+1)) +
            "</li>";
        }
        else {
          elt.itemshtml += "<li>" +
            subForm.html.replace(/XXXkeyXXX/g, idx).replace(/XXXidxXXX/g, (idx+1)) +
            "</li>";
        }

        // Propagate possible event handlers of the subform to the main form
        self.eventhandlers = self.eventhandlers.concat(subForm.eventhandlers);
      }
      
      return {
        valueFound: valueFound,
        form: subForm
      };
    };

    // Compute value for the array (may be a complex array)
    elt.itemshtml = "";

    if (elt.value) {
      for (var i=0; i<elt.value.length; i++) {   
        genSubElementFormWithValue(elt.value[i], elt, i);
      }
    }
    else {
      var k = 0;
      var val = elt.key ? getObjKey(options.value, elt.key) : options.value;
      while (genSubElementFormWithValue(val, elt, k).valueFound) {
        k++;
      }
    }

    // We always need to generate a blank template to be able to add new elements
    var subFormTpl = genSubElementFormWithValue(undefined, elt, 'XXXkeyXXX').form;

    elt.itemshtmltpl = subFormTpl.html;

    //TODO move all this alongside the template declaration
    this.eventhandlers.push(["#"+elt.id,"insert",function() {

      var addMore = function(newNo) {
        if (newNo==-1) {
          newNo = $("#"+elt.iddot).children().size();
          $("#"+elt.iddot).append("<li>"+elt.itemshtmltpl.replace(/XXXkeyXXX/g, (elt.key ? elt.key+"["+newNo+"]" : newNo)).replace(/XXXidxXXX/g, (newNo+1)) +"</li>");
        }

        //Bind each sub-event handler
        _.each(subFormTpl.eventhandlers,function(subhandler) {

          var newId = subhandler[0].replace(/XXXkeyXXX/g, (elt.key ? elt.key+"["+newNo+"]" : newNo)).substring(1);
          $("#" + escapeSelector(newId)).bind(subhandler[1],subhandler[2]);
        });

      };

      $("a._jsonform-array-deletelast",$("#"+elt.iddot).parent()).click(function(evt) {
        $("#"+elt.iddot).children().last().remove();
        evt.preventDefault();
      });

      $("a._jsonform-array-addmore",$("#"+elt.iddot).parent()).click(function(evt) {
        addMore(-1);
        evt.preventDefault();
      });

      //Add handlers to existing elements
      if (elt.value) {
        for (var i=0;i<elt.value.length;i++) {
          addMore(i);
        }
      } else {
        addMore(0);
      }

    }]);
  }
  else if (elt.type === 'object') {
    // Element is an object, recurse through the list of children
    var suboptions = _.clone(options);
    if (elt.items) {
      // The form defines the fields to render for the object
      suboptions.form = elt.items;
    }
    else {
      // Render all fields by default
      suboptions.form = ['*'];
    }

    var subForm = new formFragment();
    subForm.build(suboptions);
    elt.itemshtml = subForm.html;
    subForm.html = "";
    this.concat(subForm);
  }
  else if ((elt.type === 'checkboxes') && schema.items['enum']) {
    // List of checkboxes, multiple choices accepted
    schema.items._jsonform_checkboxes_as_array = true;
    elt.itemshtml = "";
    _.each(schema.items['enum'], function (value, idx) {
      // We should do a proper formFragment but bypassing it here seems to keep the code simple
      elt.itemshtml += _template(jsonform.elementTypes["checkboxesitem"].template)({
        "elt": {
          "value": _.include(elt.value, value),
          "title": elt.titleMap ? elt.titleMap[value] : value,
          "name": elt.key + "[" + idx +"]"
        }
      });
    });
  }
  else if (elt.items) {
    // Element with children, recurse on the children and concatenate
    // the result with the form being built
    var suboptions = _.clone(options);
    suboptions.form = elt.items;

    var subForm = new formFragment();
    subForm.build(suboptions);
    elt.itemshtml = subForm.html;
    subForm.html="";
    this.concat(subForm);
  }

  if (!elt.handlers) elt.handlers = {};

  // Retrieve the template to use for the form element
  if (!elt.template && elt.type && jsonform.elementTypes[elt.type]) {
    elt.template = jsonform.elementTypes[elt.type].template;

    _.extend(elt.handlers,jsonform.elementTypes[elt.type].handlers||{});

    if (jsonform.elementTypes[elt.type].fieldtemplate) {
      elt.template = jsonform.fieldTemplate(elt.template);
    }
  }

  if (!schema.title && !elt.title) {
    elt.title = elt.key;
  }

  if (elt.handlers) {
    _.each(elt.handlers,function(hv,hk) {
      self.eventhandlers.push(["#"+elt.id,hk,function(evt) { return hv(evt,elt); }]);
    });
  }
  

  //TODO other events
  if (elt.onChange) {
    this.eventhandlers.push(["#"+elt.id,"change",elt.onChange]);
  }
  if (elt.onClick) {
    this.eventhandlers.push(["#"+elt.id,"click",elt.onClick]);
  }
  if (elt.onInsert) {
    this.eventhandlers.push(["#"+elt.id,"insert",elt.onInsert]);
  }

  // console.log("elt",elt);

  // Generate the HTML fragment for the element.
  if (elt.template) {
    var eltstr = _template(elt.template)({
      'elt': elt,
      'schema': schema,
      'escape': escapeHTML
    });
    this.html += eltstr;
  }
};


/**
 * Parses the schema recursively and generates a form that includes all
 * possible fields, using a default layout for each field.
 *
 * @function
 * @param {Object} schema The JSON schema to parse
 * @param {Object} options The JSON Form object, which may define default values
 * @param {prefix} prefix The prefix to use for key paths, when the function is
 *   called on a subportion of the initial schema.
 */
formFragment.prototype.walkElementsInSchema = function(schema, options, prefix) {
  _.each(schema.properties, function(prop, key) {
    if (prop.properties) {
      this.walkElementsInSchema(prop, options, prefix + key + ".");
    } else {
      this.buildOneElement({'key': prefix + key}, options);
    }
  },this);
};


/**
 * Generates the HTML fragment that matches the given JSON Form object
 *
 * @function
 * @param {Object} options The JSON Form object that describes the form
 *  to generate (schema and layout)
 */
formFragment.prototype.build = function (options) {

//  options = JSON.parse(JSON.stringify(options));

  // options.schema   = options
  // options.form = string if we want to add elements defined in the schema
  //                    OR object describing a new kind of element not available in options.schema

  // JSON schema shorthand
  if (options.schema && !options.schema.properties) {
    options.schema = {properties: options.schema};
  }

  // Parse and generate the form based on the elements encountered:
  // - '*' means "generate all possible fields using default layout"
  // - a key reference to target a specific data element
  // - a more complex object to generate specific form sections
  _.each(options.form, function (elt) {
    if (elt === '*') {
      this.walkElementsInSchema(options.schema,options,"");
      return;
    }

    if (_.isString(elt)) {
      elt = {
        'key': elt
      };
    }

    this.buildOneElement(elt,options);
  }, this);
};


/**
 * Returns the structured object that corresponds to the form values entered
 * by the user. The structured object follows the structure of the data schema
 * that gave birth to the form.
 *
 * @function
 * @param {Object} formelt The jQuery form element
 * @return {Object} The object that follows the data schema and matches the
 *  values entered by the user.
 */
jsonform.getFormValue = function(formelt) {
  // The values object that will be returned
  var values = {};

  // Form fields values
  var formArray = $(formelt).serializeArray();

  // The underlying data schema
  var formSchema = $(formelt).data("jsonform-schema");

  for (var i = 0; i < formArray.length; i++) {
    // Retrieve the key definition from the data schema
    var name = formArray[i].name;
    var eltSchema = getSchemaKey(formSchema.properties, formArray[i].name);
    var arrayMatch = formArray[i].name.match(reArray);

    // Handle multiple checkboxes separately as the idea is to generate
    // an array that contains the list of enumeration items that the user
    // selected.
    if (arrayMatch && eltSchema._jsonform_checkboxes_as_array) {
      name = name.replace(reArray, "");
      var cval = getObjKey(values, name) || [];
      if (formArray[i].value === "1") {
        // Value selected, push the corresponding enumeration item
        // to the data result
        cval.push(eltSchema["enum"][parseInt(arrayMatch[1],10)]);
      }
      setObjKey(values, name, cval);
      continue;
    }

    // Skip the input field if it's not part of the schema
    if (!eltSchema) continue;

    // Type casting
    if (eltSchema.type=="boolean") {
      if (formArray[i].value==="0") {
        formArray[i].value = false;
      } else {
        formArray[i].value = !!formArray[i].value;
      }
    }
    if (eltSchema.type=="number") {
      if (_.isString(formArray[i].value)) {
        if (!formArray[i].value.length) {
          formArray[i].value = undefined;
        } else if (!isNaN(Number(formArray[i].value))) {
          formArray[i].value = Number(formArray[i].value);
        }
      }
    }
    if (eltSchema.type=="string" && formArray[i].value==="" && !eltSchema._jsonform_allowEmpty) {
      formArray[i].value=null;
    }
    if (eltSchema.type=="object" && _.isString(formArray[i].value) && formArray[i].value.substring(0,1)=="{") {
      try {
        formArray[i].value = JSON.parse(formArray[i].value);
      } catch (e) {
        formArray[i].value = {};
      }
    }
    //TODO is this due to a serialization bug?
    if (eltSchema.type=="object" && (formArray[i].value==="null" || formArray[i].value==="")) {
      formArray[i].value = null;
    }

    if (formArray[i].name && formArray[i].value!==null) {
      setObjKey(values, formArray[i].name, formArray[i].value);
    }
  }
  // console.log("Form value",values);
  return values;
};


/**
 * Highlights errors reported by the JSON schema validator in the document.
 *
 * @function
 * @param {Object} errors List of errors reported by the JSON schema validator
 * @param {Object} options The JSON Form object that describes the form
 *  (unused for the time being, could be useful to store example values or
 *   specific error messages)
 */
$.fn.jsonFormErrors = function(errors, options) {
  $(".error", this).removeClass("error");
  $(".warning", this).removeClass("warning");

  $(".jsonform-errortext", this).hide();
  if (!errors) return;

  for (var i = 0; i < errors.length; i++) {
    // Compute the address of the input field in the form from the URI
    // returned by the JSON schema validator.
    // These URIs typically look like:
    //  urn:uuid:cccc265e-ffdd-4e40-8c97-977f7a512853#/pictures/1/thumbnail
    // What we need from that is the path in the value object:
    //  pictures[1].thumbnail
    // ... and the jQuery-friendly class selector of the input field:
    //  .jsonform-error-pictures\[1\]---thumbnail
    var key = errors[i].uri
      .replace(/.*#\//, '')
      .replace(/\//g, '.')
      .replace(/\.([0-9]+)(\.|$)/, '[$1]$2');
    var errormarkerclass = ".jsonform-error-" + escapeSelector(key.replace(/\./g,"---"))
      ;

    var errorType = errors[i].type || "error";
    $(errormarkerclass, this).addClass(errorType);
    $(errormarkerclass + " .jsonform-errortext", this).html(errors[i].message).show();
  }
};


/**
 * Generates the HTML form from the given JSON Form object and renders the form.
 *
 * Main entry point of the library. Defined as a jQuery function that typically
 * needs to be applied to a <form> element in the document.
 *
 * @function
 * @param {Object} options The JSON Form object to use as basis for the form
 */
$.fn.jsonForm = function(options) {
  var formElt = this;

  var form = new formFragment();

  form.build(options);

  if (options.transloadit) {
    form.html+='<input type="hidden" name="params" value=\''+escapeHTML(JSON.stringify(options.transloadit.params))+'\'>';
  }

  formElt.append(form.html);

  formElt.data("jsonform-schema",options.schema);

  formElt.unbind((options.submitEvent||'submit')+'.jsonform');

  //console.log("bind",form.eventhandlers);
  for (var i=0;i<form.eventhandlers.length;i++) {
    var targetid = escapeSelector(form.eventhandlers[i][0].substring(1));
    var target = $("#" + targetid);
    if (form.eventhandlers[i][1]=="insert") {
      form.eventhandlers[i][2]({"target":target});
    } else {
      target.bind(form.eventhandlers[i][1],form.eventhandlers[i][2]);
    }
  }

  //return true=stop event
  var realSubmit = function(errors,values) {

    if (options.validate!==false) {
      var validator = false;
      if (typeof options.validate!="object") {
        if (global.JSONFormValidator) {
          validator = global.JSONFormValidator.createEnvironment("json-schema-draft-03");
        }
      } else {
        validator = options.validate;
      }
      if (validator) {
        var v = validator.validate(values,options.schema);
        formElt.jsonFormErrors(false,options);
        if (v.errors.length) {
          if (!errors) errors = [];
          errors = errors.concat(v.errors);
        }
      }
    }

    if (errors) {
      if (options.displayErrors) {
        options.displayErrors(errors,formElt);
      } else {
        formElt.jsonFormErrors(errors,options);
      }
    }

    if (options.onSubmit) {
      return options.onSubmit(errors,values);
    }
    if (options.onSubmitValid) {
      if (!errors) {
        return options.onSubmitValid(values);
      } else {
        return false;
      }
    }

    return true;
  };

  formElt.bind((options.submitEvent||'submit')+'.jsonform', function(event) {
    var value = jsonform.getFormValue(this);
    var stopEvent = false;

    //TODO is there an easier way to do this w/ jQuery?
    var someInputsHaveValue=false;
    $("input[type=file]",formElt).each(function() {
      someInputsHaveValue=someInputsHaveValue||!!$(this).val();
    });

    //When there's no transloadit or none submitted, skip transloadit support
    if (!options.transloadit || !someInputsHaveValue) {
      stopEvent = !realSubmit(null,value);

    //transloadit already bound?
    } else if (formElt.data("transloadit.uploader")) {
      stopEvent = !realSubmit(null,value);

    } else {
      //console.log("transload setup");

      formElt.transloadit({
        autoSubmit:false,
        wait:true,
        onSuccess:function(assembly) {
          //console.log("assembly done",assembly);

          if (assembly.results[":original"]) {
            for (var i=0;i<assembly.results[":original"].length;i++) {
              var f = assembly.results[":original"][i];
              delete value[f.field];
              setObjKey(value,f.field.replace(/^_transloadit_/,""),f);
            }
          }

          realSubmit(null,value);

          //unbind
          formElt.data("transloadit.uploader","");
          formElt.unbind("submit.transloadit");

        },
        //debug:false,
        onError:function(assembly) {
          //console.log("Assembly error",assembly);
        }
      });

      //replace jsonform's submit
      formElt.unbind("submit.jsonform");
      formElt.submit();

      stopEvent=true;
    }

    if (stopEvent) {
      event.preventDefault();
      event.stopPropagation();
    }
  });

  // Initialize tabs sections, if any
  initializeTabs(formElt);

  // Initialize expandable sections, if any
  $('.expandable > div, .expandable > fieldset', formElt).hide();
  $('.expandable > legend', formElt).click(function () {
    var parent = $(this).parent();
    parent.toggleClass('expanded');
    $('> div', parent).slideToggle(100);
  });
};


/**
 * Retrieves the structured values object generated from the values
 * entered by the user and the data schema that gave birth to the form.
 *
 * Defined as a jQuery function that typically needs to be applied to
 * a <form> element whose content has previously been generated by a
 * call to "jsonForm".
 *
 * Unless explicitly disabled, the values are automatically validated
 * against the constraints expressed in the schema.
 *
 * @function
 * @return {Object} Structured values object that matches the user inputs
 *  and the data schema.
 */
$.fn.jsonFormValue = function() {
  return jsonform.getFormValue(this);
};

// Expose the getFormValue method to the global object
// (other methods exposed as jQuery functions)
global.JSONForm = global.JSONForm || {};
global.JSONForm.getFormValue = jsonform.getFormValue;
global.JSONForm.fieldTemplate = jsonform.fieldTemplate;

})(jQuery, _, JSON, window);

