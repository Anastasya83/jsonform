/**
 * @fileoverview Core of the JSON Form client-side library.
 *
 * Generates an HTML form from a structured data model and a layout description.
 *
 * The library may also validate inputs entered by the user against the data model
 * upon form submission and create the structured data object initialized with the
 * values that were submitted.
 *
 * The library depends on:
 *  - jQuery
 *  - the underscore library
 *  - a JSON parser/serializer. Nothing to worry about in modern browsers.
 *  - the JSONFormValidation library (in jsv.js) for validation purpose
 *
 * See documentation at:
 * http://developer.joshfire.com/doc/dev/ref/jsonform
 */

 /*global window*/

(function($, _, JSON, global) {

  /**
   * Regular expressions used to extract array indexes in input field names
   */
  var reArray = /\[([0-9]*)\](?:\.|$)/g;
  var reArraySingle = /\[([0-9]*)\](?:\.|$)/;

  /**
   * The jsonform object whose methods will be exposed to the window object
   */
  var jsonform = {};

  // from Underscorejs
  // We copy it here to avoid conflicts with _.templateSettings
  var _template = function(str, data) {

    var c  = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g
    };

    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +
      'with(obj||{}){__p.push(\'' +
      str.replace(/\\/g, '\\\\')
         .replace(/'/g, "\\'")
         .replace(c.interpolate, function(match, code) {
           return "'," + code.replace(/\\'/g, "'") + ",'";
         })
         .replace(c.evaluate || null, function(match, code) {
           return "');" + code.replace(/\\'/g, "'")
                              .replace(/[\r\n\t]/g, ' ') + "__p.push('";
         })
         .replace(/\r/g, '\\r')
         .replace(/\n/g, '\\n')
         .replace(/\t/g, '\\t') +
         "');}return __p.join('');";

    var func = new Function('obj', tmpl);

    return data ? func(data) : func;
  };


// From backbonejs
// TODO replace by (new Option(JSON.stringify(html))).innerHTML ?
var escapeHTML = function(string) {
  if (!string) return '';
  return ('' + string).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
};

/**
 * Escapes selector name for use with jQuery
 *
 * All meta-characters listed in jQuery doc are escaped:
 * http://api.jquery.com/category/selectors/
 *
 * @function
 * @param {String} selector The jQuery selector to escape
 * @return {String} The escaped selector.
 */
var escapeSelector = function (selector) {
  return selector.replace(/([\!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, '\\$1');
};

/**
 * Initializes tabular sections in forms. Such sections are generated by the
 * 'selectfieldset' type of elements in JSON Form.
 *
 * Input fields that are not visible are automatically disabled
 * not to appear in the submitted form. That's on purpose, as tabs
 * are meant to convey an alternative (and not a sequence of steps).
 *
 * The tabs menu is not rendered as tabs but rather as a select field because
 * it's easier to grasp that it's an alternative.
 *
 * Code based on bootstrap-tabs.js, updated to:
 * - react to option selection instead of tab click
 * - disable input fields in non visible tabs
 * - disable the possibility to have dropdown menus (no meaning here)
 * - act as a regular function instead of as a jQuery plug-in.
 *
 * @function
 * @param {Object} tabs jQuery object that contains the tabular sections
 *  to initialize. The object may reference more than one element.
 */
var initializeTabs = function (tabs) {
  var activate = function (element, container) {
    container
      .find('> .active')
      .removeClass('active');
    element.addClass('active');
  };

  var optionSelected = function (e) {
    var $option = $("option:selected", $(this)),
      $select = $(this),
      href = $option.attr('value'),
      $href;

    if ( /^#\w+/.test(href) ) {
      href = href.substring(href.indexOf('#') + 1);
      e.preventDefault();
      if ($option.hasClass('active')) {
        return;
      }

      $href = $("#" + escapeSelector(href));
      activate($option, $select);
      activate($href, $href.parent());

      // Enable all fields in the targeted tab
      $href.find('input, textarea, select').removeAttr('disabled');

      // Disable all fields in other tabs
      $href.parent()
        .children(':not(#' + escapeSelector(href) + ')')
        .find('input, textarea, select')
        .attr('disabled', 'disabled');
    }
  };

  var tabClicked = function (e) {
    var $a = $('a', $(this));
    var $content = $('.tab-content', $(this).parent().parent());
    var $tabs = $('.tab-pane', $content);
    var $href = null;

    e.preventDefault();
    $href = $($tabs.get($(this).index()));
    activate($(this), $(this).parent());
    activate($href, $href.parent());
  };

  tabs.each(function () {
    $(this).delegate('select.nav', 'change', optionSelected);
    $('select.nav').each(function () {
      $(this).val($('.active', $(this)).attr('value'));
    });

    $(this).delegate('ul.nav li', 'click', tabClicked);
    $('ul.nav li.active').click();
  });
};


// Twitter bootstrap-friendly HTML boilerplate for standard inputs
jsonform.fieldTemplate = function(inner) {
  return '<div class="control-group jsonform-error-<%= keydash %> <%= elt.htmlClass?elt.htmlClass:"" %>">'+
          '<label class="control-label" for="<%= id %>"><% if (!elt.notitle) { %><%= elt.title %><% } %></label>'+
            '<div class="controls <% if (elt.prepend) { %>input-prepend<% } %> <% if (elt.append) { %>input-append<% } %>">'+
            '<% if (elt.prepend) { %><span class="add-on"><%= elt.prepend %></span><% } %>'+
            inner+
            '<% if (elt.append) { %><span class="add-on"><%= elt.append %></span><% } %>'+
            '<% if (elt.description) { %><span class="help-inline"><%= elt.description %></span><% } %>'+
            '<span class="help-block jsonform-errortext" style="display:none;"></span>'+
          '</div></div>';
};

var fileDisplayTemplate = '<% if (value.type=="image") { %><img id="jsonformpreview-<%= id %>" src="<%= value.url %>" /><% } else { %><a href="<%= value.url %>"><%= value.name %></a> (<%= Math.ceil(value.size/1024) %>kB)<% } %><br/>';

jsonform.elementTypes = {
  'root': {
    'template': '<div><%= children %></div>'
  },
  'text':{
    'template':'<input class="input-xlarge xlarge" type="text" name="<%= node.name %>" value="<%= escape(value) %>" id="<%= id %>" />',
    'fieldtemplate': true,
    'inputfield': true
  },
  'password':{
    'template':'<input class="input-xlarge xlarge" type="password" name="<%= node.name %>" value="<%= escape(value) %>" id="<%= id %>" />',
    'fieldtemplate': true,
    'inputfield': true
  },
  'textarea':{
    'template':'<textarea id="<%= id %>" name="<%= node.name %>" style="height:<%= elt.height || "150px" %>;width:<%= elt.width || "100%" %>;"><%= value %></textarea>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'wysihtml5':{
    'template':'<textarea id="<%= id %>" name="<%= node.name %>" style="height:<%= elt.height || "300px" %>;width:<%= elt.width || "100%" %>;"><%= value %></textarea>',
    'fieldtemplate': true,
    'inputfield': true,
    'onInsert': function (evt, node) {
      var setup = function () {
        //protect from double init
        if ($(node.el).data("wysihtml5")) return;
        $(node.el).data("wysihtml5_loaded",true);
        
        $(node.el).wysihtml5({
          "html": true,
          "link": false, //TODO replug when adding new twitter bootstrap javascripts
          "font-styles":false,
          "image": false
        });
      };

      // Is there a setup hook?
      if (window.jsonform_wysihtml5_setup) {
        window.jsonform_wysihtml5_setup(setup);
        return;
      }

      // Wait until wysihtml5 is loaded
      var itv = window.setInterval(function() {
        if (window.wysihtml5) {
          window.clearInterval(itv);
          setup();
        }
      },1000);
    }
  },
  'ace':{
    'template':'<div id="<%= id %>" style="position:relative;height:<%= elt.height || "300px" %>;"><div id="<%= id %>__ace" style="width:<%= elt.width || "100%" %>;height:<%= elt.height || "300px" %>;"><%= value %></div><input type="hidden" name="<%= node.name %>" id="<%= id %>__hidden" value="<%= escape(value) %>"/></div>',
    'fieldtemplate': true,
    'inputfield': true,
    'onInsert': function (evt, node) {
      var setup = function () {
        var ace = window.ace;
        var editor = ace.edit(node.id + "__ace");
        var idSelector = "#"+escapeSelector(node.id)+"__hidden";
        editor.setTheme("ace/theme/"+(node.aceTheme||"twilight"));

        if (node.aceMode) {
          var mode = ace.require("ace/mode/"+node.aceMode).Mode;
          editor.getSession().setMode(new mode());
        }
        editor.getSession().setTabSize(2);

        // Set the contents of the initial manifest file
        editor.getSession().setValue(node.value||"");

        //TODO this is clearly sub-optimal
        editor.getSession().on('change', function() {
          $(idSelector).val(editor.getSession().getValue());
        });

        editor.on('blur', function() {
          $(idSelector).change();
          $(idSelector).trigger("blur");
        });
        editor.on('focus', function() {
          $(idSelector).trigger("focus");
        });
      };

      // Is there a setup hook?
      if (window.jsonform_ace_setup) {
        window.jsonform_ace_setup(setup);
        return;
      }

      // Wait until ACE is loaded
      var itv = window.setInterval(function() {
        if (window.ace) {
          window.clearInterval(itv);
          setup();
        }
      },1000);
    }
  },
  'checkbox':{
    // NB: if inlinetitle is not set, a good old (sigh!) non breakable space is
    // inserted to avoid float clearing problems
    'template':'<label class="checkbox"><input type="checkbox" id="<%= id %>" name="<%= node.name %>" value="1" <% if (value) {%>checked<% } %> /><span><%= elt.inlinetitle || " " %></span></label>',
    'fieldtemplate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    }
  },
  'file':{
    'template':'<input class="input-file" id="<%= id %>" name="<%= node.name %>" type="file" />',
    'fieldtemplate': true,
    'inputfield': true
  },
  'file-transloadit':{
    'template':'<div><% if (value && (value.type||value.url)) { %>'+fileDisplayTemplate+'<% } %><input id="_transloadit_<%= id %>" type="file" name="_transloadit_<%= node.name %>" /><input type="hidden" id="<%= id %>" name="<%= node.name %>" value=\'<%= escape(JSON.stringify(value)) %>\' /></div>',
    'fieldtemplate': true,
    'inputfield': true,
    'getElement': function (el) {
      return $(el).parent().get(0);
    }
  },
  'select':{
    'template':'<select name="<%= node.name %>" id="<%= id %>"> <% _.each(elt.options, function(key, val) { if(key instanceof Object) { if (value === key.value) { %> <option selected value="<%= key.value %>"><%= key.title %></option> <% } else { %> <option value="<%= key.value %>"><%= key.title %></option> <% }} else { if (value === key) { %> <option selected value="<%= key %>"><%= key %></option> <% } else { %><option value="<%= key %>"><%= key %></option> <% }}}); %> </select>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'radios':{
    'template':'<div id="<%= node.id %>"><% _.each(elt.options, function(key, val) { %><label class="radio"><input type="radio" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked="checked" <% } %> name="<%= node.name %>" value="<%= (key instanceof Object ? key.value : key) %>"><span><%= (key instanceof Object ? key.title : key) %></span></label><% }); %></div>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'checkboxesitem':{
    // NB: if title is not set, a good old (sigh!) non breakable space is
    // inserted to avoid float clearing problems
    'template':'<label class="checkbox <%= elt.htmlClass?elt.htmlClass:"" %>"><input type="checkbox" <% if (value) { %> checked="checked" <% } %> name="<%= node.name %>" value="1"><span><%= elt.title || schema.title || " " %></span></label>',
    'inputfield': true
  },
  'checkboxes':{
    'template':'<%= children %>',
    'fieldtemplate': true,
    'inputfield': true
  },
  'array': {
    'template': '<div><ul id="<%= id %>" class="_jsonform-array-ul" style="list-style-type:none;"><%= children %></ul><span class="_jsonform-array-buttons"><a href="#" class="_jsonform-array-addmore">Add more</a> | <a href="#"  class="_jsonform-array-deletelast">Delete last</a></span></div>',
    'fieldtemplate': true,
    'childTemplate': function (inner) {
      return '<li data-idx="<%= node.childPos %>">' +
        inner +
        '<span class="_jsonform-array-buttons">' +
          '<a href="#" class="_jsonform-array-additem">Add item</a> | ' +
          '<a href="#" class="_jsonform-array-moveup">Move up</a> | ' +
          '<a href="#" class="_jsonform-array-movedown">Move down</a> | ' +
          '<a href="#" class="_jsonform-array-deleteitem">Delete item</a>' +
        '</span>' +
        '</li>';
    },
    'getElement': function (el) {
      return $(el).parent().get(0);
    },
    'array': true,
    'onInsert': function (evt, node) {
      /**
       * Create an item in the array at the requested position
       */
      var addMore = function (idx) {
        var i = 0;

        // Insert element at the end of the array if index is not given
        if (idx === undefined) {
          idx = node.children.length;
        }

        // Create the additional array item from the array item template
        // and insert it at the end of the list
        var child = node.childTemplate.clone();
        node.appendChild(child);
        child.computeInitialValues();
        child.render($('#' + escapeSelector(node.id)).get(0));

        // Shift values from array items that are to be after the
        // one to insert (note we start with the end of the array on purpose)
        for (i = node.children.length-2; i >= idx; i--) {
          child = node.children[i];
          node.children[i+1].resetValues();
          child.moveValuesTo(node.children[i+1]);
        }

        // Set initial values from default values on the blank child
        // and (re-)render it
        child = node.children[idx];
        child.resetValues();
        child.computeInitialValues();
        child.render($('#' + escapeSelector(node.id)).get(0));
      };

      /**
       * Delete item
       */
      var deleteItem = function (idx) {
        var i = 0;
        var child = null;

        // Delete last item if no index is given
        if (idx === undefined) {
          idx = node.children.length - 1;
        }

        // Shift values from array items that are after the one to delete
        for (i = idx; i < node.children.length-1; i++) {
          child = node.children[i];
          child.resetValues();
          node.children[i+1].moveValuesTo(child);
        }

        // Remove the last array item from the DOM tree and from the form tree.
        node.removeChild();
      };

      /**
       * Moves an item up
       */
      var moveUp = function (idx) {
        // TODO: add / delete the right nodes
      };

      var moveDown = function (idx) {
        
      };

      $('a._jsonform-array-deletelast', $(node.el).parent()).click(function (evt) {
        deleteItem();
        evt.preventDefault();
      });

      $('a._jsonform-array-addmore', $(node.el).parent()).click(function (evt) {
        addMore();
        evt.preventDefault();
      });

      $(node.el).parent().on('click', 'a._jsonform-array-additem', function (evt) {
        var idx = $(evt.target).parent().parent().attr('data-idx');
        idx = parseInt(idx, 10) + 1;
        addMore(idx);
        evt.preventDefault();
      });

      $(node.el).parent().on('click', 'a._jsonform-array-moveup', function (evt) {
        var idx = $(evt.target).parent().parent().attr('data-idx');
        idx = parseInt(idx, 10);
        moveUp(idx);
        evt.preventDefault();
      });

      $(node.el).parent().on('click', 'a._jsonform-array-movedown', function (evt) {
        var idx = $(evt.target).parent().parent().attr('data-idx');
        idx = parseInt(idx, 10);
        moveDown(idx);
        evt.preventDefault();
      });

      $(node.el).parent().on('click', 'a._jsonform-array-deleteitem', function (evt) {
        var idx = $(evt.target).parent().parent().attr('data-idx');
        idx = parseInt(idx, 10);
        deleteItem(idx);
        evt.preventDefault();
      });
    }
  },
  'tabarray': {
    'template': '<div class="tabbable tabs-left" id="<%= id %>">' +
      '<ul class="nav nav-tabs">' +
        '<%= elt.itemstabs %>' +
      '</ul>' +
      '<div class="tab-content">' +
        '<%= children %>' +
      '</div>' +
      '</div>' +
      '<span class="_jsonform-array-buttons">' +
        '<a href="#" class="_jsonform-array-addmore">Add more</a> | '+
        '<a href="#"  class="_jsonform-array-deletelast">Delete last</a>' +
      '</span>',
    'fieldtemplate': true,
    'array': true
  },
  'help':{
    'template':'<span class="help-block" style="padding-top:5px"><%= elt.helpvalue %></span>',
    'fieldtemplate': true
  },
  'fieldset':{
    'template': '<fieldset class="control-group jsonform-error-<%= keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:"" %>" ' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      '>' +
      '<% if (elt.legend || elt.title) { %><legend><%= elt.legend || elt.title %></legend><% } %>' +
      '<% if (elt.expandable) { %><div class="control-group"><% } %>' +
      '<%= children %>' +
      '<% if (elt.expandable) { %></div><% } %>' +
      '</fieldset>'
  },
  'advancedfieldset': {
    'template': '<fieldset' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Advanced options</legend>' +
      '<div class="control-group">' +
      '<%= children %>' +
      '</div>' +
      '</fieldset>'
  },
  'authfieldset': {
    'template': '<fieldset' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      ' class="expandable <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<legend>Authentication settings</legend>' +
      '<div class="control-group">' +
      '<%= children %>' +
      '</div>' +
      '</fieldset>'
  },
  'submit':{
    'template':'<input type="submit" <% if (id) { %> id="<%= id %>" <% } %> class="btn btn-primary <%= elt.htmlClass?elt.htmlClass:"" %>" value="<%= value || elt.title %>"/>'
  },
  'button':{
    'template':'<button id="<%= id %>" class="btn <%= elt.htmlClass?elt.htmlClass:"" %>"><%= elt.title %></button>'
  },
  'actions':{
    'template':'<div class="form-actions <%= elt.htmlClass?elt.htmlClass:"" %>"><%= children %></div>'
  },
  'hidden':{
    'template':'<input type="hidden" id="<%= id %>" name="<%= node.name %>" value="<%= escape(value) %>" />',
    'inputfield': true
  },
  'selectfieldset': {
    'template': '<fieldset class="tab-container <%= elt.htmlClass?elt.htmlClass:"" %>">' +
      '<% if (elt.legend || elt.title) { %><legend><%= elt.legend || elt.title %></legend><% } %>' +
      '<div class="tabbable">' +
        '<div class="control-group">' +
          '<label class="control-label" for="<%= id %>"><% if (!elt.notitle) { %><%= elt.title %><% } %></label>' +
          '<div class="controls"><%= tabs %></div>' +
        '</div>' +
        '<div class="tab-content">' +
          '<%= children %>' +
        '</div>' +
      '</div>' +
      '</fieldset>',
    'completeTemplateData': function (data, node) {
      // Before rendering, this function ensures that:
      // 1. direct children have IDs (used to show/hide the tabs contents)
      // 2. the tab to active is flagged accordingly. The active tab is
      // the first one, except if form values are available, in which case
      // it's the first tab for which there is some value available (or back
      // to the first one if there are none)
      // 3. the HTML of the select field used to select tabs is exposed in the
      // HTML template data as "tabs"
      var activeChild = _.find(node.children, function (child) {
        return child.hasNonDefaultValue();
      });
      if (!activeChild) {
        activeChild = node.children[0];
      }
      _.each(node.children, function (child) {
        if (!child.id) {
          child.id = escapeSelector(node.ownerTree.formDesc.prefix) +
            '-elt-counter-' + _.uniqueId();
        }
        if (child === activeChild) {
          child.active = true;
        }
      });

      var tabs = '<select class="nav">';
      _.each(node.children, function (child) {
        tabs += '<option value="#' + escapeHTML(child.id) + '"' +
          (child.active ? ' class="active"' : '') +
          '>' +
          escapeHTML(child.formElement.legend || child.formElement.title) +
          '</option>';
      });
      tabs += '</select>';
      data.tabs = tabs;
      return data;
    }
  },
  'optionfieldset': {
    'template': '<div class="<%= (elt.htmlClass ? (elt.htmlClass + " ") : "") %>' +
      'tab-pane' +
      '<% if (node.active) { %> active<% } %>"' +
      '<% if (node.id) { %> id="<%= node.id %>"<% } %>' +
      '>' +
      '<%= children %>' +
      '</div>'
  },
  'tabfieldset': {
    'template': '<div class="<%= (elt.htmlClass ? (elt.htmlClass + " ") : "") %>' +
      'tab-pane' +
      '<% if (elt.active) { %> active<% } %>"' +
      '<% if (id) { %> id="<%= id %>"<% } %>' +
      '>' +
      '<%= children %>' +
      '<%= elt.itemsbuttons %>' +
      '</div>'
  },
  'object': {
    'template': '<%= children %>'
  }
};

/*
Legacy elements:

'file-jquery-multiple': jsonform.defaultFieldTemplate('<div id="<%= id %>"><div class="fileupload-buttonbar"><label class="fileinput-button"><span>Add files...</span><input type="file" name="<%= node.name %>" multiple></label><button type="submit" class="start">Start upload</button><button type="reset" class="cancel">Cancel upload</button><button type="button" class="delete">Delete files</button></div><div class="fileupload-content"><table class="files"></table><div class="fileupload-progressbar"></div></div></div>'),
*/

//Allow to access subproperties by splitting "."
/**
 * Retrieves the key identified by a path selector in the structured object.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * @function
 * @param {Object} obj Structured object to parse
 * @param {String} key Path to the key to retrieve
 * @param {boolean} ignoreArrays True to use first element in an array when
 *   stucked on a property. This parameter is basically only useful when
 *   parsing a JSON schema for which the "items" property may either be an
 *   object or an array with one object (only one because JSON form does not
 *   support mix of items for arrays).
 * @return {Object} The key's value.
 */
var getObjKey = function (obj, key, ignoreArrays) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;

  for (var i = 0; i < keyparts.length; i++) {
    if (typeof innerobj !== "object") return null;
    subkey = keyparts[i];
    arrayMatch = subkey.match(reArraySingle);
    if (arrayMatch) {
      // Subkey is part of an array
      subkey = subkey.replace(reArraySingle, '');
      if (!_.isArray(innerobj[subkey])) {
        return null;
      }
      innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
    }
    else if (ignoreArrays && !innerobj[subkey] && _.isArray(innerobj) && innerobj[0]) {
      innerobj = innerobj[0][subkey];
    }
    else {
      innerobj = innerobj[subkey];
    }
  }

  if (ignoreArrays && _.isArray(innerobj) && innerobj[0]) {
    return innerobj[0];
  }
  else {
    return innerobj;
  }
};


/**
 * Sets the key identified by a path selector to the given value.
 *
 * Levels in the path are separated by a dot. Array items are marked
 * with [x]. For instance:
 *  foo.bar[3].baz
 *
 * The hierarchy is automatically created if it does not exist yet.
 *
 * @function
 * @param {Object} obj The object to build
 * @param {String} key The path to the key to set where each level
 *  is separated by a dot, and array items are flagged with [x].
 * @param {Object} value The value to set, may be of any type.
 */
var setObjKey = function(obj,key,value) {
  var innerobj = obj;
  var keyparts = key.split(".");
  var subkey = null;
  var arrayMatch = null;
  for (var i = 0; i < keyparts.length-1; i++) {
    subkey = keyparts[i];
    arrayMatch = subkey.match(reArraySingle);
    if (arrayMatch) {
      // Subkey is part of an array
      subkey = subkey.replace(reArraySingle, '');
      if (!_.isArray(innerobj[subkey])) {
        innerobj[subkey] = [];
      }
      if (typeof innerobj[subkey][parseInt(arrayMatch[1], 10)] !== 'object') {
        innerobj[subkey][parseInt(arrayMatch[1], 10)] = {};
      }
      innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
    }
    else {
      // "Normal" subkey
      if (typeof innerobj[subkey] !== 'object') {
        innerobj[subkey] = {};
      }
      innerobj = innerobj[subkey];
    }
  }

  // Set the final value
  subkey = keyparts[keyparts.length - 1];
  arrayMatch = subkey.match(reArraySingle);
  if (arrayMatch) {
    subkey = subkey.replace(reArraySingle, '');
    if (!_.isArray(innerobj[subkey])) {
      innerobj[subkey] = [];
    }
    innerobj[subkey][parseInt(arrayMatch[1], 10)] = value;
  }
  else {
    innerobj[subkey] = value;
  }
};


/**
 * Retrieves the key definition from the given schema.
 *
 * The key is identified by the path that leads to the key in the
 * structured object that the schema would generate. Each level is
 * separated by a '.'. Array levels are marked with []. For instance:
 *  foo.bar[].baz
 * ... to retrieve the definition of the key at the following location
 * in the JSON schema (using a dotted path notation):
 *  foo.properties.bar.items.properties.baz
 *
 * @function
 * @param {Object} schema The JSON schema to retrieve the key from
 * @param {String} key The path to the key, each level being separated
 *  by a dot and array items being flagged with [].
 * @return {Object} The key definition in the schema, null if not found.
 */
var getSchemaKey = function(schema,key) {
  var schemaKey = key
    .replace(/\./g, '.properties.')
    .replace(reArray, '.items');
  return getObjKey(schema, schemaKey, true);
};


/**
 * Truncates the key path to the requested depth.
 *
 * For instance, if the key path is:
 *  foo.bar[].baz.toto[].truc[].bidule
 * and the requested depth is 2, the returned key will be:
 *  foo.bar[].baz.toto[]
 *
 * @function
 * @param {String} key The path to the key in the schema, each level being
 *  separated by a dot and array items being flagged with [].
 * @param {Number} depth The array depth
 * @return {String} The path to the key truncated to the given depth.
 */
var truncateToArrayDepth = function (key, arrayDepth) {
  var depth = 0;
  var pos = 0;
  if (!key) return null;

  while (depth < arrayDepth) {
    pos = key.indexOf('[]', pos);
    if (pos === -1) {
      // Key path is not "deep" enough, simply return the full key
      return key;
    }
    depth += 1;
  }
  return key.substring(0, pos+2);
};

/**
 * Applies the array path to the key path.
 *
 * For instance, if the key path is:
 *  foo.bar[].baz.toto[].truc[].bidule
 * and the arrayPath [4, 2], the returned key will be:
 *  foo.bar[4].baz.toto[2].truc[].bidule
 *
 * @function
 * @param {String} key The path to the key in the schema, each level being
 *  separated by a dot and array items being flagged with [].
 * @param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]
 * @return {String} The path to the key that matches the array path.
 */
var applyArrayPath = function (key, arrayPath) {
  var depth = 0;
  if (!key) return null;
  if (!arrayPath || (arrayPath.length === 0)) return key;
  var newKey = key.replace(reArray, function (str, p1) {
    // Note this function gets called as many times as there are [x] in the ID,
    // from left to right in the string. The goal is to replace the [x] with
    // the appropriate index in the new array path.
    var newIndex = ('' + arrayPath[depth]) || '';
    depth += 1;
    return '[' + newIndex + ']';
  });
  return newKey;
};


/**
 * Returns true if the element contains some pre-defined value.
 *
 * @function
 * @param {Object} element Form element
 * @returns {boolean} true when there exist some value for the
 *  given form element, false otherwise
 */
var formElementHasValue = function (element, options) {
  var i = 0;
  var valueFound = false;

  if (_.isString(element)) {
    valueFound = element.value ||
      (options.value && getObjKey(options.value, element));
  }
  else if (element.key) {
    valueFound = element.value ||
      (options.value && getObjKey(options.value, element.key));
  }

  if (!valueFound && element.items) {
    for (i = 0; i < element.items.length; i++) {
      valueFound = formElementHasValue(element.items[i], options);
      if (valueFound) {
        break;
      }
    }
  }
  return valueFound;
};


/**
 * Represents a node in the form.
 *
 * Nodes that have an ID are linked to the corresponding DOM element
 * when rendered
 *
 * Note the form element and the schema elements that gave birth to the
 * node may be shared among multiple nodes (in the case of arrays).
 *
 * @class
 */
var formNode = function () {
  /**
   * The node's ID (may not be set)
   */
  this.id = null;

  /**
   * The node's key path (may not be set)
   */
  this.key = null;

  /**
   * DOM element associated witht the form element.
   *
   * The DOM element is set when the form element is rendered.
   */
  this.el = null;

  /**
   * Link to the form element that describes the node's layout
   * (note the form element is shared among nodes in arrays)
   */
  this.formElement = null;

  /**
   * Link to the schema element that describes the node's value constraints
   * (note the schema element is shared among nodes in arrays)
   */
  this.schemaElement = null;

  /**
   * Node's subtree (if one is defined)
   */
  this.children = [];

  /**
   * A pointer to the form tree the node is attached to
   */
  this.ownerTree = null;

  /**
   * A pointer to the parent node of the node in the tree
   */
  this.parentNode = null;

  /**
   * Child template for array-like nodes.
   *
   * The child template gets cloned to create new array items.
   */
  this.childTemplate = null;

  /**
   * The path of indexes that lead to the current node when the
   * form element is not at the root array level.
   *
   * Note a form element may well be nested element and still be
   * at the root array level. That's typically the case for "fieldset"
   * elements. An array level only gets created when a form element
   * is of type "array" (or a derivated type such as "tabarray").
   *
   * The array path of a form element linked to the foo[2].bar.baz[3].toto
   * element in the submitted values is [2, 3] for instance.
   *
   * The array path is typically used to compute the right ID for input
   * fields. It is also used to update positions when an array item is
   * created, moved around or suppressed.
   *
   * @type {Array(Number)}
   */
  this.arrayPath = [];

  /**
   * Position of the node in the list of children of its parents
   */
  this.childPos = 0;
};


/**
 * Clones a node
 *
 * @function
 * @return {formNode} Cloned node
 */
formNode.prototype.clone = function () {
  var node = new formNode();
  node.arrayPath = _.clone(this.arrayPath);
  node.ownerTree = this.ownerTree;
  node.parentNode = this.parentNode;
  node.formElement = this.formElement;
  node.schemaElement = this.schemaElement;
  node.children = _.map(this.children, function (child) {
    return child.clone();
  });
  if (this.childTemplate) {
    node.childTemplate = this.childTemplate.clone();
  }
  return node;
};


/**
 * Returns true if the subtree that starts at the current node
 * has some non empty value attached to it
 */
formNode.prototype.hasNonDefaultValue = function () {
  if (this.value && !this.defaultValue) {
    return true;
  }
  var child = _.find(this.children, function (child) {
    return child.hasNonDefaultValue();
  });
  return !!child;
};


/**
 * Attaches a child node to the current node.
 *
 * The child node is appended to the end of the list.
 *
 * @function
 * @param {formNode} node The child node to append
 * @return {formNode} The inserted node (same as the one given as parameter)
 */
formNode.prototype.appendChild = function (node) {
  node.parentNode = this;
  node.childPos = this.children.length;
  this.children.push(node);
  return node;
};


/**
 * Removes the child at the given position
 *
 * TODO: shift other items around
 *
 * @function
 * @param {Number} pos Position of the child to remove
 */
formNode.prototype.removeChild = function (pos) {
  var i = 0;
  var child = this.children[this.children.length-1];
  if (!child) return;

  // Remove the child from the DOM
  $(child.el).remove();

  // Remove the last child in the array
  return this.children.pop();
};


/**
 * Moves the user entered values set in the current node's subtree to the
 * given node's subtree.
 *
 * The target node must follow the same structure as the current node
 * (typically, they should have been generated from the same node template)
 *
 * The target must have been previously "reset" through a call to resetValues.
 *
 * Moving values around allows to insert/remove array items at arbitrary
 * positions.
 *
 * @function
 * @param {formNode} node Target node.
 */
formNode.prototype.moveValuesTo = function (node) {
  var params = null;
  var nodeChild = null;
  var idx = 0;

  if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].inputfield) {
    // Simple input field, extract the value from the origin,
    // set the target value and reset the origin value
    params = $(':input', this.el).serializeArray();
    _.each(params, function (param) {
      // Parameter name is e.g. foo[1].bar[1].baz.toto, and we may be moving
      // the first array level to index position 3, meaning the goal is to
      // set foo[3].bar[1].baz.toto
      var targetName = applyArrayPath(param.name, node.arrayPath);
      var target = $('[name="' + escapeSelector(targetName) + '"]', $(node.el));
      target.val(param.value);
    }, this);
  }
  else if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].array) {
    // The current node is an array, the target node needs to have the
    // same number of children (that may not be enough!)
    for (idx = 0; idx < this.children.length; idx++) {
      node.appendChild(node.childTemplate.clone());
    }
  }

  // Recurse down the subtree
  _.each(this.children, function (child, idx) {
    nodeChild = node.children[idx];
    child.moveValuesTo(nodeChild);
  }, this);
};


/**
 * Resets all DOM values in the node's subtree.
 *
 * This operation also drops all array item nodes (save one!)
 * Note values are not reset to their default values, they are rather removed!
 *
 * @function
 */
formNode.prototype.resetValues = function () {
  var params = null;
  var idx = 0;

  if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].inputfield) {
    // Simple input field, extract the value from the origin,
    // set the target value and reset the origin value
    params = $(':input', this.el).serializeArray();
    _.each(params, function (param) {
      // TODO: check this, there may exist corner cases with this approach
      // (with multiple checkboxes for instance)
      $('[name="' + escapeSelector(param.name) + '"]', $(this.el)).val(param.value);
    }, this);
  }
  else if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].array) {
    // The current node is an array, drop all children
    while (this.children.length > 0) {
      this.removeChild();
    }
  }
};


/**
 * Sets the child template node for the current node.
 *
 * The child template node is used to create additional children
 * in an array-like form element. The template is never rendered.
 *
 * @function
 * @param {formNode} node The child template node to set
 */
formNode.prototype.setChildTemplate = function (node) {
  this.childTemplate = node;
  node.parentNode = this;
};


/**
 * Recursively sets values to all nodes of the current subtree
 * based on previously submitted values, or based on default
 * values when the submitted values are not enough
 *
 * The function should be called once in the lifetime of a node
 * in the tree. It expects its parent's arrayPath to be up to date.
 *
 * Three cases may arise:
 * 1. if the form element is a simple input field, the value is
 * extracted from previously submitted values of from default values
 * defined in the schema.
 * 2. if the form element is an array-like node, the child template
 * is used to create as many children as possible (and at least one).
 * 3. the function simply recurses down the node's subtree otherwise
 * (this happens when the form element is a fieldset-like element).
 *
 * @function
 * @param {Object} values Previously submitted values for the form
 */
formNode.prototype.computeInitialValues = function (values) {
  var nbChildren = 1;
  var i = 0;

  // Propagate the array path from the parent node
  // (adding the position of the child for nodes that are direct
  // children of array-like nodes)
  if (this.parentNode) {
    this.arrayPath = _.clone(this.parentNode.arrayPath);
    if (this.parentNode.formElement &&
      jsonform.elementTypes[this.parentNode.formElement.type].array) {
      this.arrayPath.push(this.childPos);
    }
  }
  else {
    this.arrayPath = [];
  }

  // Compute the ID of the field (if needed)
  if (this.formElement) {
    if (this.formElement.id) {
      this.id = applyArrayPath(this.formElement.id, this.arrayPath);
    }
    else if (jsonform.elementTypes[this.formElement.type].array) {
      this.id = escapeSelector(this.ownerTree.formDesc.prefix) +
        '-elt-counter-' + _.uniqueId();
    }
    if (this.formElement.key) {
      this.key = applyArrayPath(this.formElement.key, this.arrayPath);
      this.keydash = this.key.replace(/\./g, '---');
    }
    this.name = applyArrayPath(this.formElement.name, this.arrayPath);

    // Use form element's value if defined to start with
    this.value = this.formElement.value;
  }

  if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].inputfield) {
    // Case 1: simple input field
    if (values) {
      // Form has already been submitted, use former value if defined.
      // Note we won't set the field to its default value otherwise
      // (since the user has already rejected it)
      if (getObjKey(values, this.formElement.key)) {
        this.value = getObjKey(values, this.formElement.key);
      }
    }
    else {
      // No previously submitted form result, use default value
      // defined in the schema if it's available
      if (this.schemaElement['default']) {
        this.value = this.schemaElement['default'];
        this.defaultValue = true;
      }
    }
  }
  else if (this.formElement &&
    jsonform.elementTypes[this.formElement.type].array) {
    // Case 2: array-like node
    nbChildren = this.getPreviousNumberOfItems(values, this.arrayPath);
    if (nbChildren === 0) nbChildren = 1;
    for (i = 0; i < nbChildren; i++) {
      this.appendChild(this.childTemplate.clone());
    }
    _.each(this.children, function (child) {
      child.computeInitialValues(values);
    });
  }
  else {
    // Case 3: recurse through the list of children
    _.each(this.children, function (child) {
      child.computeInitialValues(values);
    });
  }

  // Current value has just been set, trigger the "onElementValue"
  // event that caller may use to plug custom behavior
  // (tidoust: not sure that behavior is still required, leaving
  // it for backward compatibility, setting value to the formElement
  // as before)
  // TODO: this is wrong since formElement may be shared among form nodes,
  // and not value! Ensure the code that relies on onElementValue in the
  // Factory gets updated and drop this!
  if (this.formElement) {
    this.formElement.value = this.value;
    if (this.ownerTree.formDesc.onElementValue) {
      this.ownerTree.formDesc.onElementValue(this.formElement, this.schemaElement);
    }
  }
};


/**
 * Returns the number of items that the array node should have based on
 * previously submitted values.
 *
 * The whole difficulty is that values may be hidden deep in the subtree
 * of the node and may actually target different arrays in the JSON schema.
 *
 * @function
 * @param {Object} values Previously submitted values
 * @param {Array(Number)} arrayPath the array path we're interested in
 * @return {Number} The number of items in the array
 */
formNode.prototype.getPreviousNumberOfItems = function (values, arrayPath) {
  var key = null;
  var arrayValue = null;
  var childNumbers = null;
  var idx = 0;

  if (!values) {
    // No previously submitted values, no need to go any further
    return 0;
  }

  if (jsonform.elementTypes[this.formElement.type].inputfield) {
    // Case 1: node is a simple input field that links to a key in the schema.
    // The schema key looks typically like:
    //  foo.bar[].baz.toto[].truc[].bidule
    // The goal is to apply the array path and truncate the key to the last
    // array we're interested in, e.g. with an arrayPath [4, 2]:
    //  foo.bar[4].baz.toto[2]
    key = truncateToArrayDepth(this.formElement.key, arrayPath.length);
    key = applyArrayPath(key, arrayPath);
    arrayValue = getObjKey(values, key);
    if (!arrayValue) {
      // No key? That means this field had been left empty
      // in previous submit
      return 0;
    }
    return arrayValue.length;
  }
  else if (jsonform.elementTypes[this.formElement.type].array) {
    // Case 2: node is an array-like node, look for input fields
    // in its child template
    return this.childTemplate.getPreviousNumberOfItems(values, arrayPath);
  }
  else {
    // Case 3: node is a leaf or a container,
    // recurse through the list of children and return the maximum
    // number of items found in each subtree
    childNumbers = _.map(this.children, function (child) {
      return child.getPreviousNumberOfItems(values, arrayPath);
    });
    return _.max(childNumbers) || 0;
  }
};


/**
 * Renders the node.
 *
 * Rendering is done in three steps: HTML generation, DOM element creation
 * and insertion, and an enhance step to bind event handlers.
 *
 * @function
 * @param {Node} el The DOM element where the node is to be rendered. The
 *  node is inserted at the right position based on its "childPos" property.
 */
formNode.prototype.render = function (el) {
  var html = this.generate();
  this.setContent(html, el);
  this.enhance();
};


/**
 * Inserts/Updates the HTML content of the node in the DOM.
 *
 * If the HTML is an update, the new HTML content replaces the old one and
 * is moved to the appropriate position if it's not already where it should be
 * (that may only happen in arrays when nodes are moved around)
 *
 * The HTML is inserted at the right position in its parent's DOM subtree
 * otherwise (well, provided there are enough children, but that should always
 * be the case).
 *
 * @function
 * @param {string} html The HTML content to render
 * @param {Node} parentEl The DOM element that is to contain the DOM node.
 *  This parameter is optional (the node's parent is used otherwise) and
 *  is ignored if the node to render is already in the DOM tree.
 */
formNode.prototype.setContent = function (html, parentEl) {
  var node = $(html);
  var parentNode = parentEl ||
    this.parentNode ||
    this.ownerTree.domRoot;
  var nextSibling = null;

  if (this.el) {
    // Replace the contents of the DOM element if the node is already in the tree
    $(this.el).replaceWith(node);
    // TODO: move the node to the right position based on childPos?
  }
  else {
    // Insert the node in the DOM if it's not already there
    nextSibling = $(parentNode).children().get(this.childPos);
    if (nextSibling) {
      $(nextSibling).before(node);
    }
    else {
      $(parentNode).append(node);
    }
  }

  // Save the link between the form node and the generated HTML
  this.el = node;

  // Update the node's subtree, extracting DOM elements that match the nodes
  // from the generated HTML
  this.updateElement(this.el);
};


/**
 * Updates the DOM element associated with the node.
 *
 * Only nodes that have ID are directly associated with a DOM element.
 *
 * @function
 */
formNode.prototype.updateElement = function (domNode) {
  if (this.id) {
    this.el = $('#' + escapeSelector(this.id), domNode).get(0);
    if (this.formElement &&
      jsonform.elementTypes[this.formElement.type].getElement) {
      this.el = jsonform.elementTypes[this.formElement.type].getElement(this.el);
    }
    if (this.formElement &&
      jsonform.elementTypes[this.formElement.type].fieldtemplate) {
      // The field template wraps the element two level deep in the DOM tree
      this.el = $(this.el).parent().parent().get(0);
    }
    if (this.parentNode && this.parentNode.formElement &&
      jsonform.elementTypes[this.parentNode.formElement.type].childTemplate) {
      // TODO: the child template may introduce more than one level,
      // so the number of levels introduced should rather be exposed
      // somehow in jsonform.fieldtemplate.
      this.el = $(this.el).parent().get(0);
    }
  }
  else {
    this.el = null;
  }

  _.each(this.children, function (child) {
    child.updateElement(this.el || domNode);
  });
};


/**
 * Generates the view's HTML content for the underlying model.
 *
 * @function
 */
formNode.prototype.generate = function () {
  var view = jsonform.elementTypes[
    this.parentNode ? this.formElement.type : 'root'
  ];
  var data = {
    id: this.id,
    keydash: this.keydash,
    elt: this.formElement,
    schema: this.schemaElement,
    node: this,
    value: this.value,
    escape: escapeHTML
  };
  var template = view.template;
  var html = '';

  // Wrap the view template in the generic field template
  if (view.fieldtemplate || view.fieldTemplate) {
    template = jsonform.fieldTemplate(view.template);
  }

  // Wrap the content in the child template of its parent if necessary.
  if (this.parentNode && this.parentNode.formElement &&
    jsonform.elementTypes[this.parentNode.formElement.type].childTemplate) {
    template = jsonform.elementTypes[this.parentNode.formElement.type].childTemplate(template);
  }

  // Complete the data context if needed
  if (view.completeTemplateData) {
    data = view.completeTemplateData(data, this);
  }

  // Prepare the HTML of the children
  var childrenhtml = '';
  _.each(this.children, function (child) {
    childrenhtml += child.generate();
  });
  data.children = childrenhtml;

  // Apply the HTML template
  html = _template(template)(data);
  return html;
};


/**
 * Enhances the view with additional logic, binding event handlers
 * in particular.
 *
 * The function also runs the "insert" event handler of the view and
 * form element if they exist (starting with that of the view)
 *
 * @function
 */
formNode.prototype.enhance = function () {
  if (this.formElement) {
    // Check the view associated with the node as it may define an "onInsert"
    // event handler to be run right away
    var view = jsonform.elementTypes[this.formElement.type];
    if (view.onInsert) {
      view.onInsert({ target: $(this.el) }, this);
    }

    // Trigger the "insert" event handler
    if (this.formElement.onInsert) {
      this.formElement.onInsert({ target: $(this.el) }, this);
    }
    if (this.formElement.handlers) {
      _.each(this.formElement.handlers, function (handler, onevent) {
        if (onevent === 'insert') {
          handler({ target: $(this.el) });
        }
      }, this);
    }

    // No way to register event handlers if the DOM element is unknown
    if (this.el) {
      // Register specific event handlers
      // TODO: Add support for other event handlers
      if (this.formElement.onChange) {
        $(this.el).bind('change', this.formElement.onChange);
      }
      if (this.formElement.onClick) {
        $(this.el).bind('click', this.formElement.onClick);
      }

      if (this.formElement.handlers) {
        _.each(this.formElement.handlers, function (handler, onevent) {
          if (onevent !== 'insert') {
            $(this.el).bind(onevent, handler);
          }
        }, this);
      }
    }
  }

  // Recurse down the tree to enhance children
  _.each(this.children, function (child) {
    child.enhance();
  });
};


/**
 * Form tree class.
 *
 * Holds the internal representation of the form.
 * The tree is always in sync with the rendered form, this allows to parse
 * it easily.
 *
 * @class
 */
var formTree = function () {
  this.eventhandlers = [];
  this.root = null;
  this.formDesc = null;
};

/**
 * Initializes the form tree structure from the JSONForm object
 *
 * @function
 */
formTree.prototype.initialize = function (formDesc) {
  formDesc = formDesc || {};

  // Keep a pointer to the initial JSONForm
  // (note clone returns a shallow copy, only first-level is cloned)
  this.formDesc = _.clone(formDesc);

  // Compute form prefix if no prefix is given.
  this.formDesc.prefix = this.formDesc.prefix ||
    'jsonform-' + _.uniqueId();

  // JSON schema shorthand
  if (this.formDesc.schema && !this.formDesc.schema.properties) {
    this.formDesc.schema = {
      properties: this.formDesc.schema
    };
  }

  // Ensure layout is set
  this.formDesc.form = this.formDesc.form || ['*'];
  this.formDesc.form = (_.isArray(this.formDesc.form) ?
    this.formDesc.form :
    [this.formDesc.form]);

  // Create the root of the tree
  this.root = new formNode();
  this.root.ownerTree = this;

  // Generate the tree from the form description
  this.buildTree();

  // Compute the values associated with each node
  // (for arrays, the computation actually creates the form nodes)
  this.computeInitialValues();
};


/**
 * Constructs the tree from the form description.
 *
 * The function must be called once when the tree is first created.
 *
 * @function
 */
formTree.prototype.buildTree = function () {
  // Parse and generate the form structure based on the elements encountered:
  // - '*' means "generate all possible fields using default layout"
  // - a key reference to target a specific data element
  // - a more complex object to generate specific form sections
  _.each(this.formDesc.form, function (formElement) {
    if (formElement === '*') {
      _.each(this.formDesc.schema.properties, function (element, key) {
        this.root.appendChild(this.buildFromLayout({
          key: key
        }));
      }, this);
    }
    else {
      if (_.isString(formElement)) {
        formElement = {
          key: formElement
        };
      }
      this.root.appendChild(this.buildFromLayout(formElement));
    }
  }, this);
};


/**
 * Builds the internal form tree representation from the requested layout.
 *
 * The function is recursive, generating the node children as necessary.
 * The function extracts the values from the previously submitted values
 * (this.formDesc.value) or from default values defined in the schema.
 *
 * @function
 * @param {Object} formElement JSONForm element to render
 * @param {Object} context The parsing context (the array depth in particular)
 * @return {Object} The node that matches the element.
 */
formTree.prototype.buildFromLayout = function (formElement, context) {
  var schemaElement = null;
  var self = this;
  var node = new formNode();
  var key = null;

  // The form element parameter directly comes from the initial
  // JSONForm object. We'll make a shallow copy of it and of its children
  // not to pollute the original object.
  // (note JSON.parse(JSON.stringify()) cannot be used since there may be
  // event handlers in there!)
  formElement = _.clone(formElement);
  if (formElement.items) {
    if (_.isArray(formElement.items)) {
      formElement.items = _.map(formElement.items, _.clone);
    }
    else {
      formElement.items = [ _.clone(formElement.items) ];
    }
  }

  if (formElement.key) {
    // The form element is directly linked to an element in the JSON
    // schema. The properties of the form element override those of the
    // element in the JSON schema. Properties from the JSON schema complete
    // those of the form element otherwise.

    // Retrieve the element from the JSON schema
    schemaElement = getSchemaKey(
      this.formDesc.schema.properties,
      formElement.key);
    if (!schemaElement) {
      // The JSON Form is invalid!
      throw new Error('The JSONForm object references the schema key "' +
        formElement.key + '" but that key does not exist in the JSON schema');
    }

    // Schema element has just been found, let's trigger the
    // "onElementSchema" event
    // (tidoust: not sure what the use case for this is, keeping the
    // code for backward compatibility)
    if (this.formDesc.onElementSchema) {
      this.formDesc.onElementSchema(formElement, schemaElement);
    }

    formElement.name = formElement.name ||
      formElement.key;
    formElement.title = formElement.title ||
      schemaElement.title ||
      formElement.key;
    formElement.description = formElement.description ||
      schemaElement.description;

    // Compute the ID of the input field
    if (!formElement.id) {
      formElement.id = escapeSelector(this.formDesc.prefix) +
        '-elt-' + formElement.key;
    }

    // Should empty strings be included in the final value?
    // TODO: it's rather unclean to pass it through the schema.
    // tidoust: hmmm, no idea why this code is here actually.
    if (formElement.allowEmpty) {
      schemaElement._jsonform_allowEmpty = true;
    }

    // If the form element does not define its type, use the type of
    // the schema element.
    if (!formElement.type) {
      if ((schemaElement.type === 'number' ||
          schemaElement.type === 'string') &&
        !schemaElement['enum']) {
        formElement.type = 'text';
      } else if (schemaElement.type === 'boolean') {
        formElement.type = 'checkbox';
      } else if (!_.isUndefined(schemaElement['enum'])) {
        formElement.type = 'select';
      } else {
        formElement.type = schemaElement.type;
      }
    }

    // Unless overridden in the definition of the form element (or unless
    // there's a titleMap defined), use the enumeration list defined in
    // the schema
    if (!formElement.options && schemaElement['enum']) {
      if (formElement.titleMap) {
        formElement.options = _.map(schemaElement['enum'], function (value) {
          return {
            value: value,
            title: formElement.titleMap[value] || value
          };
        });
      }
      else {
        formElement.options = schemaElement['enum'];
      }
    }

    // Flag a list of checkboxes with multiple choices
    // TODO: not sure about the need to have this.
    if ((formElement.type === 'checkboxes') && schemaElement.items) {
      var itemsEnum = schemaElement.items['enum'];
      if (!itemsEnum && schemaElement.items[0]) {
        itemsEnum = schemaElement.items[0]['enum'];
      }
      if (itemsEnum) {
        schemaElement.items._jsonform_checkboxes_as_array = true;
      }
    }

    // If the form element targets an "object" in the JSON schema,
    // we need to recurse through the list of children to create an
    // input field per child property of the object in the JSON schema
    if (schemaElement.type === 'object') {
      _.each(schemaElement.properties, function (prop, propName) {
        node.appendChild(this.buildFromLayout({
          key: formElement.key + '.' + propName
        }));
      }, this);
    }
  }

  // Abort if the form element does not define its type
  if (!formElement.type) {
    throw new Error('The JSONForm contains an element whose type is not set');
  }
  if (!jsonform.elementTypes[formElement.type]) {
    throw new Error('The JSONForm contains an element whose type is unknown: "' +
      formElement.type + '"');
  }

  if (schemaElement) {
    // The form element is linked to an element in the schema.
    // Let's make sure the types are compatible.
    // In particular, the element must not be a "container"
    // (or must be an "object" or "array" container)
    if (!jsonform.elementTypes[formElement.type].inputfield &&
      !jsonform.elementTypes[formElement.type].array &&
      (formElement.type !== 'object')) {
      throw new Error('The JSONForm contains an element that links to an ' +
        'element in the JSON schema (key: "' + formElement.key + '") ' +
        'and that should not based on its type ("' + formElement.type + '")');
    }
  }
  else {
    // The form element is not linked to an element in the schema.
    // This means the form element must be a "container" element,
    // and must not define an input field.
    if (jsonform.elementTypes[formElement.type].inputfield) {
      throw new Error('The JSONForm defines an element of type ' +
        '"' + formElement.type + '" ' +
        ' but no "key" property to link the input field to the JSON schema');
    }
  }

  // A few characters need to be escaped to use the ID as jQuery selector
  formElement.iddot = escapeSelector(formElement.id || '');

  // Initialize the form node from the form element and schema element
  node.formElement = formElement;
  node.schemaElement = schemaElement;
  node.ownerTree = this;

  // Set event handlers
  if (!formElement.handlers) {
    formElement.handlers = {};
  }

  // Parse children recursively
  if (jsonform.elementTypes[formElement.type].array) {
    // The form element is an array. The number of items in an array
    // is by definition dynamic, up to the form user (through "Add more",
    // "Delete" commands). The positions of the items in the array may
    // also change over time (through "Move up", "Move down" commands).
    //
    // The form node stores a "template" node that serves as basis for
    // the creation of an item in the array.
    //
    // Array items may be complex forms themselves, allowing for nesting.
    //
    // The initial values set the initial number of items in the array.
    // Note a form element contains at least one item when it is rendered.
    if (formElement.items) {
      key = formElement.items[0] || formElement.items;
    }
    else {
      key = formElement.key + '[]';
    }
    if (_.isString(key)) {
      key = { key: key };
    }
    node.setChildTemplate(this.buildFromLayout(key));
  }
  else if (formElement.items) {
    // The form element defines children elements
    _.each(formElement.items, function (item) {
      if (_.isString(item)) {
        item = { key: item };
      }
      node.appendChild(this.buildFromLayout(item));
    }, this);
  }

  return node;
};


/**
 * Computes the values associated with each input field in the tree based
 * on previously submitted values or default values in the JSON schema.
 *
 * For arrays, the function actually creates and inserts additional
 * nodes in the tree based on previously submitted values (also ensuring
 * that the array has at least one item).
 *
 * The function sets the array path on all nodes.
 * It should be called once in the lifetime of a form tree right after
 * the tree structure has been created.
 *
 * @function
 */
formTree.prototype.computeInitialValues = function () {
  this.root.computeInitialValues(this.formDesc.value);
};


/**
 * Renders the form tree
 *
 * @function
 * @param {Node} domRoot The "form" element in the DOM tree that serves as
 *  root for the form
 */
formTree.prototype.render = function (domRoot) {
  if (!domRoot) return;
  this.domRoot = domRoot;
  this.root.render();
};


/**
 * Returns the structured object that corresponds to the form values entered
 * by the user. The structured object follows the structure of the data schema
 * that gave birth to the form.
 *
 * @function
 * @param {Object} formelt The jQuery form element
 * @return {Object} The object that follows the data schema and matches the
 *  values entered by the user.
 */
jsonform.getFormValue = function(formelt) {
  // The values object that will be returned
  var values = {};

  // Form fields values
  var formArray = $(formelt).serializeArray();

  // The underlying data schema
  var formSchema = $(formelt).data("jsonform-schema");

  for (var i = 0; i < formArray.length; i++) {
    // Retrieve the key definition from the data schema
    var name = formArray[i].name;
    var eltSchema = getSchemaKey(formSchema.properties, formArray[i].name);
    var arrayMatch = formArray[i].name.match(reArray);

    // Handle multiple checkboxes separately as the idea is to generate
    // an array that contains the list of enumeration items that the user
    // selected.
    if (arrayMatch && eltSchema._jsonform_checkboxes_as_array) {
      name = name.replace(reArray, "");
      var cval = getObjKey(values, name) || [];
      if (formArray[i].value === "1") {
        // Value selected, push the corresponding enumeration item
        // to the data result
        cval.push(eltSchema["enum"][parseInt(arrayMatch[1],10)]);
      }
      setObjKey(values, name, cval);
      continue;
    }

    // Skip the input field if it's not part of the schema
    if (!eltSchema) continue;

    // Type casting
    if (eltSchema.type=="boolean") {
      if (formArray[i].value==="0") {
        formArray[i].value = false;
      } else {
        formArray[i].value = !!formArray[i].value;
      }
    }
    if (eltSchema.type=="number") {
      if (_.isString(formArray[i].value)) {
        if (!formArray[i].value.length) {
          formArray[i].value = undefined;
        } else if (!isNaN(Number(formArray[i].value))) {
          formArray[i].value = Number(formArray[i].value);
        }
      }
    }
    if (eltSchema.type=="string" && formArray[i].value==="" && !eltSchema._jsonform_allowEmpty) {
      formArray[i].value=null;
    }
    if (eltSchema.type=="object" && _.isString(formArray[i].value) && formArray[i].value.substring(0,1)=="{") {
      try {
        formArray[i].value = JSON.parse(formArray[i].value);
      } catch (e) {
        formArray[i].value = {};
      }
    }
    //TODO is this due to a serialization bug?
    if (eltSchema.type=="object" && (formArray[i].value==="null" || formArray[i].value==="")) {
      formArray[i].value = null;
    }

    if (formArray[i].name && formArray[i].value!==null) {
      setObjKey(values, formArray[i].name, formArray[i].value);
    }
  }
  // console.log("Form value",values);
  return values;
};


/**
 * Highlights errors reported by the JSON schema validator in the document.
 *
 * @function
 * @param {Object} errors List of errors reported by the JSON schema validator
 * @param {Object} options The JSON Form object that describes the form
 *  (unused for the time being, could be useful to store example values or
 *   specific error messages)
 */
$.fn.jsonFormErrors = function(errors, options) {
  $(".error", this).removeClass("error");
  $(".warning", this).removeClass("warning");

  $(".jsonform-errortext", this).hide();
  if (!errors) return;

  for (var i = 0; i < errors.length; i++) {
    // Compute the address of the input field in the form from the URI
    // returned by the JSON schema validator.
    // These URIs typically look like:
    //  urn:uuid:cccc265e-ffdd-4e40-8c97-977f7a512853#/pictures/1/thumbnail
    // What we need from that is the path in the value object:
    //  pictures[1].thumbnail
    // ... and the jQuery-friendly class selector of the input field:
    //  .jsonform-error-pictures\[1\]---thumbnail
    var key = errors[i].uri
      .replace(/.*#\//, '')
      .replace(/\//g, '.')
      .replace(/\.([0-9]+)(\.|$)/, '[$1]$2');
    var errormarkerclass = ".jsonform-error-" +
      escapeSelector(key.replace(/\./g,"---"));

    var errorType = errors[i].type || "error";
    $(errormarkerclass, this).addClass(errorType);
    $(errormarkerclass + " .jsonform-errortext", this).html(errors[i].message).show();
  }
};


/**
 * Generates the HTML form from the given JSON Form object and renders the form.
 *
 * Main entry point of the library. Defined as a jQuery function that typically
 * needs to be applied to a <form> element in the document.
 *
 * The function handles the following properties for the JSON Form object it
 * receives as parameter:
 * - schema (required): The JSON Schema that describes the form to render
 * - form: The options form layout description, overrides default layout
 * - prefix: String to use to prefix computed IDs. Default is an empty string.
 *  Use this option if JSON Form is used multiple times in an application with
 *  schemas that have overlapping parameter names to avoid running into multiple
 *  IDs issues. Default value is "jsonform-[counter]".
 * - transloadit: Transloadit parameters when transloadit is used
 * - validate: Validates form against schema upon submission. Uses the value
 * of the "validate" property as validator if it is an object.
 * - displayErrors: Function to call with errors upon form submission.
 *  Default is to render the errors next to the input fields.
 * - submitEvent: Name of the form submission event to bind to.
 *  Default is "submit".
 * - onSubmit: Callback function to call when form is submitted
 * - onSubmitValid: Callback function to call when form is submitted without
 *  errors.
 *
 * @function
 * @param {Object} options The JSON Form object to use as basis for the form
 */
$.fn.jsonForm = function(options) {
  var formElt = this;

  options = options || {};

  var form = new formTree();
  form.initialize(options);
  form.render(formElt.get(0));

  // TODO: move that to formTree.render
  if (options.transloadit) {
    formElt.append('<input type="hidden" name="params" value=\'' +
      escapeHTML(JSON.stringify(options.transloadit.params)) +
      '\'>');
  }

  // Keep a direct pointer to the JSON schema for form submission purpose
  formElt.data("jsonform-schema", form.formDesc.schema);
  formElt.unbind((options.submitEvent||'submit')+'.jsonform');

  //return true=stop event
  var realSubmit = function(errors,values) {

    if (options.validate!==false) {
      var validator = false;
      if (typeof options.validate!="object") {
        if (global.JSONFormValidator) {
          validator = global.JSONFormValidator.createEnvironment("json-schema-draft-03");
        }
      } else {
        validator = options.validate;
      }
      if (validator) {
        var v = validator.validate(values, form.formDesc.schema);
        formElt.jsonFormErrors(false,options);
        if (v.errors.length) {
          if (!errors) errors = [];
          errors = errors.concat(v.errors);
        }
      }
    }

    if (errors) {
      if (options.displayErrors) {
        options.displayErrors(errors,formElt);
      } else {
        formElt.jsonFormErrors(errors,options);
      }
    }

    if (options.onSubmit) {
      return options.onSubmit(errors,values);
    }
    if (options.onSubmitValid) {
      if (!errors) {
        return options.onSubmitValid(values);
      } else {
        return false;
      }
    }

    return true;
  };

  formElt.bind((options.submitEvent||'submit')+'.jsonform', function(event) {
    var value = jsonform.getFormValue(this);
    var stopEvent = false;

    //TODO is there an easier way to do this w/ jQuery?
    var someInputsHaveValue=false;
    $("input[type=file]",formElt).each(function() {
      someInputsHaveValue=someInputsHaveValue||!!$(this).val();
    });

    //When there's no transloadit or none submitted, skip transloadit support
    if (!options.transloadit || !someInputsHaveValue) {
      stopEvent = !realSubmit(null,value);

    //transloadit already bound?
    } else if (formElt.data("transloadit.uploader")) {
      stopEvent = !realSubmit(null,value);

    } else {
      //console.log("transload setup");

      formElt.transloadit({
        autoSubmit:false,
        wait:true,
        onSuccess:function(assembly) {
          //console.log("assembly done",assembly);

          if (assembly.results[":original"]) {
            for (var i=0;i<assembly.results[":original"].length;i++) {
              var f = assembly.results[":original"][i];
              delete value[f.field];
              setObjKey(value,f.field.replace(/^_transloadit_/,""),f);
            }
          }

          realSubmit(null,value);

          //unbind
          formElt.data("transloadit.uploader","");
          formElt.unbind("submit.transloadit");

        },
        //debug:false,
        onError:function(assembly) {
          //console.log("Assembly error",assembly);
        }
      });

      //replace jsonform's submit
      formElt.unbind("submit.jsonform");
      formElt.submit();

      stopEvent=true;
    }

    if (stopEvent) {
      event.preventDefault();
      event.stopPropagation();
    }
  });

  // Initialize tabs sections, if any
  initializeTabs(formElt);

  // Initialize expandable sections, if any
  $('.expandable > div, .expandable > fieldset', formElt).hide();
  $('.expandable > legend', formElt).click(function () {
    var parent = $(this).parent();
    parent.toggleClass('expanded');
    $('> div', parent).slideToggle(100);
  });
};


/**
 * Retrieves the structured values object generated from the values
 * entered by the user and the data schema that gave birth to the form.
 *
 * Defined as a jQuery function that typically needs to be applied to
 * a <form> element whose content has previously been generated by a
 * call to "jsonForm".
 *
 * Unless explicitly disabled, the values are automatically validated
 * against the constraints expressed in the schema.
 *
 * @function
 * @return {Object} Structured values object that matches the user inputs
 *  and the data schema.
 */
$.fn.jsonFormValue = function() {
  return jsonform.getFormValue(this);
};

// Expose the getFormValue method to the global object
// (other methods exposed as jQuery functions)
global.JSONForm = global.JSONForm || {};
global.JSONForm.getFormValue = jsonform.getFormValue;
global.JSONForm.fieldTemplate = jsonform.fieldTemplate;

})(jQuery, _, JSON, window);

